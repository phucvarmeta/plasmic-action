import { ComponentMeta } from '@plasmicapp/host';
import { PlasmicDataSourceContextValue } from '@plasmicapp/data-sources-context';
import { default as React_2 } from 'react';
import { usePlasmicDataConfig } from '@plasmicapp/query';

export declare type BaseFieldConfig = {
    key?: string;
    fieldId?: string;
};

/**
 * Represents the result of a client-side query.
 */
export declare interface ClientQueryResult<T = any> {
    /**
     * The data returned by the query. May be undefined if the query has not yet completed.
     */
    data?: T;
    /**
     * The schema of the table from which the data was queried. Only available for plasmic data
     * integration. May be undefined if the query has not yet completed.
     */
    schema?: TableSchema;
    /**
     * The total number of records available. Only available for plasmic data integration. May be
     * undefined if the query has not yet completed.
     */
    total?: number;
    /**
     * Pagination information for the query result. Only available for plasmic data integration. May be
     * undefined if the query has not yet completed.
     */
    paginate?: Pagination;
    /**
     * Any error that occurred during the query. This is optional and may be undefined.
     */
    error?: any;
    /**
     * Indicates whether the query is currently loading.
     */
    isLoading?: boolean;
}

export declare interface DataOp {
    sourceId: string;
    opId: string;
    userArgs?: Record<string, any>;
    cacheKey?: string;
    invalidatedKeys?: string[] | null;
    roleId?: string | null;
}

declare interface DataOpConfig {
    name?: string;
    pageIndex?: number;
    pageSize?: number;
}

export declare interface DataSourceSchema {
    tables: TableSchema[];
}

declare interface DependencyAwareQueryConfig extends DataOpConfig {
    $queries: Record<string, any>;
    setDollarQueries: ($queries: Record<string, any>) => void;
    getDataOp: () => DataOp;
}

export declare function deriveFieldConfigs<T extends BaseFieldConfig>(specifiedFieldsPartial: Partial<T>[], schema: TableSchema | undefined, makeDefaultConfig: (field: TableFieldSchema | undefined) => T): {
    mergedFields: T[];
    minimalFullLengthFields: Partial<T>[];
};

declare interface ExecuteOpts {
    userAuthToken?: string;
    user?: PlasmicDataSourceContextValue["user"];
    paginate?: Pagination;
}

export declare function executePlasmicDataOp<T extends SingleRowResult | ManyRowsResult>(op: DataOp, opts?: ExecuteOpts): Promise<T>;

/**
 * Executes a server query, returning either the result of the query or a
 * PlasmicUndefinedServerProxy if the query depends on data that is not yet ready
 */
export declare function executeServerQuery<F extends (...args: any[]) => any>(serverQuery: ServerQuery<F>): Promise<ServerQueryResult<ReturnType<F> | {}>>;

export declare function Fetcher(props: FetcherProps): React_2.ReactElement | null;

export declare const FetcherMeta: ComponentMeta<FetcherProps>;

export declare interface FetcherProps extends DataOpConfig {
    dataOp?: DataOp;
    children?: ($queries: Record<string, any>) => React_2.ReactElement | null;
    queries?: Record<string, any>;
}

export declare function makeCacheKey(dataOp: DataOp, opts?: {
    paginate?: Pagination;
    userAuthToken?: string | null;
}): string;

export declare function makeQueryCacheKey(id: string, params: any[]): string;

export declare interface ManyRowsResult<T = any> {
    data: T[];
    total?: number;
    schema: TableSchema;
    paginate?: Pagination;
}

export declare function mkPlasmicUndefinedServerProxy(): {
    data: {};
    isLoading: boolean;
};

export declare function normalizeData(rawData: unknown): NormalizedData | undefined;

export declare interface NormalizedData {
    data: Record<string, unknown>[];
    schema?: TableSchema;
}

export declare interface Pagination {
    pageSize: number;
    pageIndex: number;
}

export declare type QueryResult = Partial<ManyRowsResult<any>> & {
    error?: any;
    isLoading?: boolean;
};

declare type ResolvableDataOp = DataOp | undefined | null | (() => DataOp | undefined | null);

export declare interface ServerQuery<F extends (...args: any[]) => Promise<any>> {
    fn: F;
    execParams: () => Parameters<F>;
    id: string;
}

export declare interface ServerQueryResult<T = any> {
    data: T;
    isLoading: boolean;
}

export declare interface SingleRowResult<T = any> {
    data: T;
    schema: TableSchema;
}

export declare interface TableFieldSchema {
    id: string;
    label?: string;
    type: TableFieldType;
    readOnly: boolean;
    primaryKey?: boolean;
    options?: string[];
}

export declare type TableFieldType = "string" | "boolean" | "number" | "date" | "datetime" | "enum" | "json" | "unknown";

export declare interface TableSchema {
    id: string;
    schema?: string;
    label?: string;
    fields: TableFieldSchema[];
}

/**
 * @deprecated Prefer using `usePlasmicDataOp` directly instead.
 */
export declare function useDependencyAwareQuery({ $queries, getDataOp, setDollarQueries, name, pageIndex, pageSize, }: DependencyAwareQueryConfig): void;

export declare function useNormalizedData(rawData: unknown): NormalizedData | undefined;

export { usePlasmicDataConfig }

export declare function usePlasmicDataMutationOp<T extends SingleRowResult | ManyRowsResult>(dataOp: ResolvableDataOp): () => Promise<T | undefined>;

export declare function usePlasmicDataOp<T extends SingleRowResult | ManyRowsResult, E = any>(dataOp: ResolvableDataOp, opts?: {
    paginate?: Pagination;
    noUndefinedDataProxy?: boolean;
}): ClientQueryResult<T["data"]>;

/**
 * Returns a function that can be used to invalidate Plasmic query groups.
 */
export declare function usePlasmicInvalidate(): (invalidatedKeys: string[] | null | undefined) => Promise<any[] | undefined>;

export declare function usePlasmicServerQuery<F extends (...args: any[]) => Promise<any>>(serverQuery: ServerQuery<F>, fallbackData?: ReturnType<F>, opts?: {
    noUndefinedDataProxy?: boolean;
}): Partial<ServerQueryResult<ReturnType<F>>>;

export { }
