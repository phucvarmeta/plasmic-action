{
  "version": 3,
  "sources": ["../src/index.tsx", "../src/components/Fetcher.tsx", "../src/hooks/usePlasmicDataOp.tsx", "../src/common.ts", "../src/executor.tsx", "../src/placeholders.ts", "../src/utils.ts", "../src/helpers.ts", "../src/hooks/useDependencyAwareQuery.tsx", "../src/serverQueries/client.ts", "../src/serverQueries/common.ts", "../src/serverQueries/server.ts"],
  "sourcesContent": ["export { usePlasmicDataConfig } from \"@plasmicapp/query\";\nexport { Fetcher, FetcherMeta } from \"./components/Fetcher\";\nexport type { FetcherProps } from \"./components/Fetcher\";\nexport { executePlasmicDataOp } from \"./executor\";\nexport {\n  deriveFieldConfigs,\n  normalizeData,\n  useNormalizedData,\n} from \"./helpers\";\nexport type { BaseFieldConfig, NormalizedData, QueryResult } from \"./helpers\";\nexport { useDependencyAwareQuery } from \"./hooks/useDependencyAwareQuery\";\nexport {\n  makeCacheKey,\n  usePlasmicDataMutationOp,\n  usePlasmicDataOp,\n  usePlasmicInvalidate,\n} from \"./hooks/usePlasmicDataOp\";\nexport {\n  makeQueryCacheKey,\n  usePlasmicServerQuery,\n} from \"./serverQueries/client\";\nexport {\n  executeServerQuery,\n  mkPlasmicUndefinedServerProxy,\n} from \"./serverQueries/server\";\nexport type {\n  ClientQueryResult,\n  DataOp,\n  DataSourceSchema,\n  ManyRowsResult,\n  Pagination,\n  ServerQuery,\n  ServerQueryResult,\n  SingleRowResult,\n  TableFieldSchema,\n  TableFieldType,\n  TableSchema,\n} from \"./types\";\n", "import { ComponentMeta } from \"@plasmicapp/host\";\nimport React from \"react\";\nimport { usePlasmicDataOp } from \"../hooks/usePlasmicDataOp\";\nimport { DataOp } from \"../types\";\n\nexport interface DataOpConfig {\n  name?: string;\n  pageIndex?: number;\n  pageSize?: number;\n}\n\nexport interface FetcherProps extends DataOpConfig {\n  dataOp?: DataOp;\n  children?: ($queries: Record<string, any>) => React.ReactElement | null;\n  queries?: Record<string, any>;\n}\n\nexport function Fetcher(props: FetcherProps): React.ReactElement | null {\n  const { dataOp, children, name, pageIndex, pageSize } = props;\n  const data = usePlasmicDataOp(dataOp, {\n    ...(!!pageIndex &&\n      !!pageSize && {\n        paginate: { pageIndex, pageSize },\n      }),\n  });\n\n  const $queries = React.useMemo(\n    () => ({ ...props.queries, [name ?? \"data\"]: data }),\n    [props.queries, name, data]\n  );\n\n  return children?.($queries) ?? null;\n}\n\nexport const FetcherMeta: ComponentMeta<FetcherProps> = {\n  name: \"plasmic-data-source-fetcher\",\n  displayName: \"Data Fetcher\",\n  props: {\n    dataOp: {\n      type: \"dataSourceOp\" as any,\n      displayName: \"Data\",\n    },\n    name: {\n      type: \"string\",\n      displayName: \"Variable name\",\n    },\n    children: {\n      type: \"slot\",\n      renderPropParams: [\"$queries\"],\n    },\n    pageSize: {\n      type: \"number\",\n      advanced: true,\n      displayName: \"Page size\",\n      description: \"Only fetch in batches of this size; for pagination\",\n    },\n    pageIndex: {\n      type: \"number\",\n      advanced: true,\n      displayName: \"Page index\",\n      description: \"0-based index of the paginated page to fetch\",\n    },\n  },\n  importPath: \"@plasmicapp/react-web/lib/data-sources\",\n  importName: \"Fetcher\",\n  alwaysAutoName: true,\n  styleSections: false,\n};\n", "import { usePlasmicDataSourceContext } from \"@plasmicapp/data-sources-context\";\nimport {\n  useMutablePlasmicQueryData,\n  usePlasmicDataConfig,\n} from \"@plasmicapp/query\";\nimport * as React from \"react\";\nimport { isPlasmicUndefinedDataErrorPromise, usePlasmicFetch } from \"../common\";\nimport { executePlasmicDataOp } from \"../executor\";\nimport {\n  ClientQueryResult,\n  DataOp,\n  ManyRowsResult,\n  Pagination,\n  SingleRowResult,\n} from \"../types\";\nimport { pick } from \"../utils\";\n\nexport function makeCacheKey(\n  dataOp: DataOp,\n  opts?: { paginate?: Pagination; userAuthToken?: string | null }\n) {\n  const queryDependencies = JSON.stringify({\n    sourceId: dataOp.sourceId,\n    opId: dataOp.opId,\n    args: dataOp.userArgs,\n    userAuthToken: opts?.userAuthToken,\n    paginate: opts?.paginate,\n  });\n  return dataOp.cacheKey\n    ? `${dataOp.cacheKey}${queryDependencies}`\n    : queryDependencies;\n}\n\n/**\n * Returns a function that can be used to invalidate Plasmic query groups.\n */\nexport function usePlasmicInvalidate() {\n  // NOTE: we use `revalidateIfStale: false` with SWR.\n  // One quirk of this is that if you supply fallback data to swr,\n  // that data doesn't get entered into the cache if `revalidateIfStale: false`,\n  // so you won't see it if you iterate over keys of the cache. That's why\n  // we have usePlasmicInvalidate() which will iterate over both the cache\n  // and the fallback data.\n  const { cache, fallback, mutate } = usePlasmicDataConfig();\n  return async (invalidatedKeys: string[] | null | undefined) => {\n    const getKeysToInvalidate = () => {\n      if (!invalidatedKeys) {\n        return [];\n      }\n      const allKeys = Array.from(\n        new Set([\n          ...Array.from((cache as any).keys()),\n          ...(fallback ? Object.keys(fallback) : []),\n          // If this is running within the Studio, we also take the\n          // opportunity to invalidate the Studio cache. The keys that\n          // Studio may have can be a superset of `cache` here, because\n          // `cache` is updated as swr hooks are mounted and unmounted,\n          // but Studio's data cache keys don't get removed when hooks\n          // are unmounted. This makes it possible for Studio to hold\n          // onto a stale cache entry that doesn't get invalidated.\n          // For example, Studio may render page1, with key X, then goes\n          // to page 2, which performs a mutate. At this point, Studio\n          // has a cache entry for key X, but `cache` does not, because\n          // page2 does not use that query. But page 2 may perform a\n          // mutation that invalidates X. So we need to invalidate not\n          // only keys in `cache`, but also keys that Studio is still\n          // holding onto.\n          ...((globalThis as any).__PLASMIC_GET_ALL_CACHE_KEYS?.() ?? []),\n        ])\n      ).filter((key): key is string => typeof key === \"string\");\n      if (invalidatedKeys.includes(\"plasmic_refresh_all\")) {\n        return allKeys;\n      }\n      return allKeys.filter((key) =>\n        invalidatedKeys.some((k) => key.includes(`.$.${k}.$.`))\n      );\n    };\n\n    const keys = getKeysToInvalidate();\n    if (keys.length === 0) {\n      return;\n    }\n\n    const invalidateKey = async (key: string) => {\n      const studioInvalidate = (globalThis as any).__PLASMIC_MUTATE_DATA_OP;\n      if (studioInvalidate) {\n        await studioInvalidate(key);\n      }\n      return mutate(key);\n    };\n\n    return await Promise.all(keys.map((key) => invalidateKey(key)));\n  };\n}\n\ntype ResolvableDataOp =\n  | DataOp\n  | undefined\n  | null\n  | (() => DataOp | undefined | null);\n\n/**\n * This returns either:\n * * DataOp to perform\n * * undefined/null, if no data op can be performed\n * * PlasmicUndefinedDataErrorPromise, if when trying to evaluate the DataOp to perform,\n *   we encounter a PlasmicUndefinedDataErrorPromise, so this operation cannot be\n *   performed until that promise is resolved.\n */\nfunction resolveDataOp(dataOp: ResolvableDataOp) {\n  if (typeof dataOp === \"function\") {\n    try {\n      return dataOp();\n    } catch (err) {\n      if (isPlasmicUndefinedDataErrorPromise(err)) {\n        return err;\n      }\n      return null;\n    }\n  } else {\n    return dataOp;\n  }\n}\n\nexport function usePlasmicDataOp<\n  T extends SingleRowResult | ManyRowsResult,\n  E = any\n>(\n  dataOp: ResolvableDataOp,\n  opts?: {\n    paginate?: Pagination;\n    noUndefinedDataProxy?: boolean;\n  }\n): ClientQueryResult<T[\"data\"]> {\n  const resolvedDataOp = resolveDataOp(dataOp);\n  const ctx = usePlasmicDataSourceContext();\n  const key =\n    !resolvedDataOp || isPlasmicUndefinedDataErrorPromise(resolvedDataOp)\n      ? null\n      : makeCacheKey(resolvedDataOp, {\n          paginate: opts?.paginate,\n          userAuthToken: ctx?.userAuthToken,\n        });\n  const fetcher = (op: DataOp) => {\n    return executePlasmicDataOp<T>(op, {\n      userAuthToken: ctx?.userAuthToken || undefined,\n      user: ctx?.user,\n      paginate: opts?.paginate,\n    });\n  };\n  const resultMapper = (\n    result: ReturnType<typeof useMutablePlasmicQueryData<T[\"data\"], E>>\n  ): ClientQueryResult<T[\"data\"]> => {\n    return {\n      ...(result.data ?? {}),\n      ...pick(result, \"error\", \"isLoading\"),\n    };\n  };\n  return usePlasmicFetch<T[\"data\"], E>(\n    key,\n    resolvedDataOp,\n    fetcher,\n    resultMapper,\n    [\"data\", \"schema\", \"error\"],\n    {\n      noUndefinedDataProxy: opts?.noUndefinedDataProxy,\n    }\n  );\n}\n\nexport function usePlasmicDataMutationOp<\n  T extends SingleRowResult | ManyRowsResult\n>(dataOp: ResolvableDataOp) {\n  const ctx = usePlasmicDataSourceContext();\n  const userToken = ctx?.userAuthToken;\n\n  const getRealDataOp = React.useCallback(async () => {\n    const tryGetRealDataOp = async (): Promise<DataOp | null> => {\n      const resolved = resolveDataOp(dataOp);\n      if (!resolved) {\n        return null;\n      } else if (isPlasmicUndefinedDataErrorPromise(resolved)) {\n        // If calling the dataOp function resulted in a data fetch,\n        // then we wait for the data fetch to finish and try\n        // again\n        await resolved;\n        return tryGetRealDataOp();\n      } else {\n        return resolved;\n      }\n    };\n    return await tryGetRealDataOp();\n  }, [dataOp]);\n\n  return React.useCallback(async () => {\n    const { sourceId, opId, userArgs } = (await getRealDataOp()) ?? {};\n\n    if (!sourceId || !opId) {\n      return undefined;\n    }\n\n    return executePlasmicDataOp<T>(\n      { sourceId, opId, userArgs },\n      {\n        userAuthToken: userToken || undefined,\n        user: ctx?.user,\n      }\n    );\n  }, [getRealDataOp, userToken]);\n}\n", "import {\n  useMutablePlasmicQueryData,\n  usePlasmicDataConfig,\n} from \"@plasmicapp/query\";\n// eslint-disable-next-line no-restricted-imports\nimport * as ph from \"@plasmicapp/host\";\nimport React from \"react\";\nimport { ClientQueryResult } from \"./types\";\n\ninterface PlasmicUndefinedDataErrorPromise extends Promise<any> {\n  plasmicType: \"PlasmicUndefinedDataError\";\n  message: string;\n}\n\nexport function isPlasmicUndefinedDataErrorPromise(\n  x: any\n): x is PlasmicUndefinedDataErrorPromise {\n  return (\n    !!x &&\n    typeof x === \"object\" &&\n    x?.plasmicType === \"PlasmicUndefinedDataError\"\n  );\n}\n\nexport function mkUndefinedDataProxy(\n  promiseRef: { fetchingPromise: Promise<any> | undefined },\n  fetchAndUpdateCache: (() => Promise<any>) | undefined\n) {\n  let fetchAndUpdatePromise: Promise<any> | undefined = undefined;\n\n  return new Proxy(\n    {},\n    {\n      get: (_target, prop) => {\n        if (prop === \"isPlasmicUndefinedDataProxy\") {\n          return true;\n        }\n\n        if (!fetchAndUpdateCache) {\n          // There's no key so no fetch to kick off yet; when computing key,\n          // we encountered some thrown exception (that's not an undefined data promise),\n          // and so we can't fetch yet. This might be dependent on a $state or $prop value\n          // that's currently undefined, etc.  We will act like an undefined data object,\n          // and trigger the usual fallback behavior\n          return undefined;\n        }\n\n        const doFetchAndUpdate = () => {\n          // We hold onto the promise last returned by fetchAndUpdateCache()\n          // and keep reusing it until it is resolved. The reason is that the\n          // Promise thrown here will be used as a dependency for memoized\n          // fetchAndUpdateCache, which is a dependency on the memoized returned value\n          // from usePlasmicDataOp(). If we have a fetch that's taking a long time,\n          // we want to make sure that our memoized returned value is stable,\n          // so that we don't keep calling setDollarQueries() (otherwise, for each\n          // render, we find an unstable result, and call setDollarQueries(),\n          // resulting in an infinite loop while fetch is happening).\n          if (!fetchAndUpdatePromise) {\n            fetchAndUpdatePromise = fetchAndUpdateCache().finally(() => {\n              fetchAndUpdatePromise = undefined;\n            });\n          }\n          return fetchAndUpdatePromise;\n        };\n\n        const promise =\n          // existing fetch\n          promiseRef.fetchingPromise ||\n          // No existing fetch, so kick off a fetch\n          doFetchAndUpdate();\n        (promise as any).plasmicType = \"PlasmicUndefinedDataError\";\n        (promise as any).message = `Cannot read property ${String(\n          prop\n        )} - data is still loading`;\n        throw promise;\n      },\n    }\n  ) as any;\n}\n\nconst isRSC = (React as any).isRSC;\nconst reactMajorVersion = +React.version.split(\".\")[0];\nconst enableLoadingBoundaryKey = \"plasmicInternalEnableLoadingBoundary\";\n\n/**\n * Fetches can be kicked off two ways -- normally, by useSWR(), or by some\n * expression accessing the `$queries.*` proxy when not ready yet. We need\n * a global cache for proxy-invoked caches, so that different components\n * with the same key can share the same fetch.\n *\n * The life cycle for this cache is short -- only the duration of a\n * proxy-invoked fetch, and once the fetch is done. That's because we really\n * just want SWR to be managing the cache, not us! Once the data is in SWR,\n * we will use SWR for getting data.\n */\nconst PRE_FETCHES = new Map<string, Promise<any>>();\n\nexport function usePlasmicFetch<T, R, E = any>(\n  key: string | null,\n  resolvedParams: any,\n  fetcherFn: (resolvedParam: any) => Promise<T>,\n  resultMapper: (\n    result: ReturnType<typeof useMutablePlasmicQueryData<T, E>>\n  ) => ClientQueryResult<R>,\n  undefinedDataProxyFields: (\"data\" | \"schema\" | \"error\")[],\n  opts: {\n    fallbackData?: T;\n    noUndefinedDataProxy?: boolean;\n  }\n) {\n  const enableLoadingBoundary = !!ph.useDataEnv?.()?.[enableLoadingBoundaryKey];\n  const { mutate, cache } = isRSC\n    ? ({} as any as Partial<ReturnType<typeof usePlasmicDataConfig>>)\n    : usePlasmicDataConfig();\n  // Cannot perform this operation\n  const isNullParams = !resolvedParams;\n  // This operation depends on another data query to resolve first\n  const isWaitingOnDependentQuery =\n    isPlasmicUndefinedDataErrorPromise(resolvedParams);\n  const fetchingData = React.useMemo(\n    () => ({\n      fetchingPromise: undefined as Promise<T> | undefined,\n    }),\n    [key]\n  );\n  const fetcher = React.useMemo(\n    () => () => {\n      // If we are in this function, that means SWR cache missed.\n      if (!key) {\n        throw new Error(`Fetcher should never be called without a proper key`);\n      }\n\n      // dataOp is guaranteed to be a DataOp, and not an undefined promise or null\n\n      if (fetchingData.fetchingPromise) {\n        // Fetch is already underway from this hook\n        return fetchingData.fetchingPromise;\n      }\n\n      if (key && PRE_FETCHES.has(key)) {\n        // Some other usePlasmicDataOp() hook elsewhere has already\n        // started this fetch as well; re-use it here.\n        const existing = PRE_FETCHES.get(key) as Promise<T>;\n        fetchingData.fetchingPromise = existing;\n        return existing;\n      }\n\n      // Else we really need to kick off this fetch now...\n      const fetcherPromise = fetcherFn(resolvedParams);\n      fetchingData.fetchingPromise = fetcherPromise;\n      if (key) {\n        PRE_FETCHES.set(key, fetcherPromise);\n        // Once we have a result, we rely on swr to perform the caching,\n        // so remove from our cache as quickly as possible.\n        fetcherPromise.then(\n          () => {\n            PRE_FETCHES.delete(key);\n          },\n          () => {\n            PRE_FETCHES.delete(key);\n          }\n        );\n      }\n      return fetcherPromise;\n    },\n    [key, fetchingData]\n  );\n\n  const dependentKeyDataErrorPromise = isPlasmicUndefinedDataErrorPromise(\n    resolvedParams\n  )\n    ? resolvedParams\n    : undefined;\n  const fetchAndUpdateCache = React.useMemo(() => {\n    if (!key && !dependentKeyDataErrorPromise) {\n      // If there's no key, and no data query we're waiting for, then there's\n      // no way to perform a fetch\n      return undefined;\n    }\n    return () => {\n      // This function is called when the undefined data proxy is invoked.\n      // USUALLY, this means the data is not available in SWR yet, and\n      // we need to kick off a fetch.\n\n      if (fetchingData.fetchingPromise) {\n        // No need to update cache as the exist promise call site will do it\n        return fetchingData.fetchingPromise;\n      }\n\n      if (dependentKeyDataErrorPromise) {\n        // We can't actually fetch yet, because we couldn't even evaluate the dataOp\n        // to fetch for, because we depend on unfetched data. Once _that_\n        // dataOp we depend on is finished, then we can try again.  So we\n        // will throw and wait for _that_ promise to be resolved instead.\n        return dependentKeyDataErrorPromise;\n      }\n\n      if (!key) {\n        throw new Error(`Expected key to be non-null`);\n      }\n\n      // SOMETIMES, SWR actually _does_ have the cache, but we still end up\n      // here.  That's because of how we update $queries, which takes two\n      // cycles; each time we render, we build a `new$Queries`, and\n      // `set$Queries(new$Queries)`.  So once the data is ready, at the\n      // first render, we will have data in `new$Queries` but not `$queries`,\n      // but we will still finish rendering that pass, which means any `$queries`\n      // access will still end up here.  So we look into the SWR cache and\n      // return any data that's here.\n      const cached = cache?.get(key);\n      if (cached) {\n        return Promise.resolve(cached);\n      }\n      const cachedError = cache?.get(`$swr$${key}`);\n      if (cachedError) {\n        return Promise.reject(cachedError.error);\n      }\n\n      // Now, upon this proxy.get() miss, we want to kick off the fetch. We can't\n      // wait for useSWR() to kick off the fetch, because upon data miss we are\n      // throwing a promise, and useSWR() won't kick off the fetch till the effect,\n      // so it will never get a chance to fetch.  Instead, we fetch, and then we\n      // put the fetched data into the SWR cache, so that next time useSWR() is called,\n      // it will just find it in the cache.\n      //\n      // However, we don't want to fetch SYNCHRONOUSLY RIGHT NOW, becase we are in\n      // the rendering phase (presumably, we're here because some component is trying\n      // to read fetched data while rendering).  Doing a fetch right now would invoke\n      // the fetcher, which is wrapped by @plasmicapp/query to tracking loading state,\n      // and upon loading state toggled to true, it will fire loading event listeners,\n      // and for example, our antd's <GlobalLoadingIndicator /> will listen to this\n      // event and immediately ask antd to show the loading indicator, which mutates\n      // antd component's state.  It is NOT LEGAL to call setState() on some other\n      // component's state during rendering phase!\n      //\n      // We therefore will delay kicking off the fetch by a tick, so that we will safely\n      // start the fetch outside of React rendering phase.\n      const fetcherPromise = new Promise((resolve, reject) => {\n        setTimeout(() => {\n          fetcher().then(resolve, reject);\n        }, 1);\n      });\n      if (!isRSC) {\n        fetcherPromise\n          .then((data) => {\n            // Insert the fetched data into the SWR cache\n            mutate?.(key, data);\n          })\n          .catch((err) => {\n            // Cache the error here to avoid infinite loop\n            const keyInfo = key ? \"$swr$\" + key : \"\";\n            cache?.set(keyInfo, { ...(cache?.get(keyInfo) ?? {}), error: err });\n          });\n      }\n      return fetcherPromise;\n    };\n  }, [fetcher, fetchingData, cache, key, dependentKeyDataErrorPromise]);\n  const res = useMutablePlasmicQueryData<T, E>(key, fetcher, {\n    fallbackData: opts?.fallbackData,\n    shouldRetryOnError: false,\n\n    // If revalidateIfStale is true, then if there's a cache entry with a key,\n    // but no mounted hook with that key yet, and when the hook mounts with the key,\n    // swr will revalidate. This may be reasonable behavior, but for us, this\n    // happens all the time -- we prepopulate the cache with proxy-invoked fetch,\n    // sometimes before swr had a chance to run the effect.  So we turn off\n    // revalidateIfStale here, and just let the user manage invalidation.\n    revalidateIfStale: false,\n  });\n  const { data, error, isLoading } = res;\n  if (fetchingData.fetchingPromise != null && data !== undefined) {\n    // Clear the fetching promise as the actual data is now used (so\n    // revalidation is possible)\n    fetchingData.fetchingPromise = undefined;\n  }\n\n  return React.useMemo(() => {\n    const result = resultMapper(res);\n    if (\n      !opts?.noUndefinedDataProxy &&\n      reactMajorVersion >= 18 &&\n      enableLoadingBoundary &&\n      (isLoading || isNullParams || isWaitingOnDependentQuery) &&\n      undefinedDataProxyFields.every((field) => result[field] === undefined)\n    ) {\n      undefinedDataProxyFields.forEach((field) => {\n        if (field === \"error\") {\n          return;\n        }\n        result[field] = mkUndefinedDataProxy(fetchingData, fetchAndUpdateCache);\n      });\n    }\n    return result;\n  }, [\n    isNullParams,\n    isWaitingOnDependentQuery,\n    data,\n    error,\n    isLoading,\n    opts?.noUndefinedDataProxy,\n    enableLoadingBoundary,\n    fetchingData,\n    fetchAndUpdateCache,\n  ]);\n}\n\n/**\n * New getConfig that reuses the `global.__PLASMIC__` object instead of having multiple\n * keys in `global`.\n */\nexport function getConfig<T>(key: string, defaultValue: T) {\n  if (typeof globalThis === \"undefined\") {\n    return defaultValue;\n  } else {\n    return (globalThis as any).__PLASMIC__?.[key] ?? defaultValue;\n  }\n}\n", "import { PlasmicDataSourceContextValue } from \"@plasmicapp/data-sources-context\";\nimport fetch from \"@plasmicapp/isomorphic-unfetch\";\nimport { wrapLoadingFetcher } from \"@plasmicapp/query\";\nimport stringify from \"fast-stringify\";\nimport { addPlaceholdersToUserArgs } from \"./placeholders\";\nimport { DataOp, ManyRowsResult, Pagination, SingleRowResult } from \"./types\";\n\nconst DEFAULT_HOST = \"https://data.plasmic.app\";\n\ninterface ExecuteOpts {\n  userAuthToken?: string;\n  user?: PlasmicDataSourceContextValue[\"user\"];\n  paginate?: Pagination;\n}\n\nconst UNAUTHORIZED_MESSAGE =\n  \"You do not have permission to perform this operation. Login to get access or contact the app owner to get access.\";\n\nexport async function executePlasmicDataOp<\n  T extends SingleRowResult | ManyRowsResult\n>(op: DataOp, opts?: ExecuteOpts) {\n  const func = getConfig(\n    \"__PLASMIC_EXECUTE_DATA_OP\",\n    _executePlasmicDataOp\n  ) as typeof _executePlasmicDataOp;\n  op.userArgs = addPlaceholdersToUserArgs(op.userArgs);\n  const res = await wrapLoadingFetcher(func)(op, opts);\n  return res as T;\n}\n\nasync function _executePlasmicDataOp<\n  T extends SingleRowResult | ManyRowsResult\n>(op: DataOp, opts?: ExecuteOpts) {\n  if (op.roleId) {\n    if (!opts?.user || !opts.user.roleIds.includes(op.roleId)) {\n      console.error(UNAUTHORIZED_MESSAGE);\n      throw new Error(UNAUTHORIZED_MESSAGE);\n    }\n  }\n\n  const host = getConfig(\"__PLASMIC_DATA_HOST\", DEFAULT_HOST);\n\n  const url = `${host}/api/v1/server-data/sources/${op.sourceId}/execute`;\n  const resp = await fetch(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...(opts?.userAuthToken && {\n        \"x-plasmic-data-user-auth-token\": opts.userAuthToken,\n      }),\n    },\n    body: stringify({\n      opId: op.opId,\n      userArgs: op.userArgs ?? {},\n      paginate: opts?.paginate,\n    }),\n  });\n  if (resp.status !== 200) {\n    const text = await resp.text();\n    throw new Error(text);\n  }\n  return (await resp.json()) as T;\n}\n\nfunction getConfig<T>(key: string, defaultValue: T) {\n  if (typeof globalThis === \"undefined\") {\n    return defaultValue;\n  } else {\n    return (globalThis as any)[key] ?? defaultValue;\n  }\n}\n", "const PLASMIC_UNDEFINED = \"__PLASMIC_UNDEFINED\";\n\nfunction addPlaceholders(val: any) {\n  return val === undefined ? PLASMIC_UNDEFINED : val;\n}\n\nexport function addPlaceholdersToUserArgs(\n  userArgs: Record<string, any> | undefined\n) {\n  if (!userArgs) {\n    return userArgs;\n  }\n  Object.entries(userArgs).forEach(([key, val]) => {\n    userArgs[key] = Array.isArray(val)\n      ? val.map((v) => addPlaceholders(v))\n      : addPlaceholders(val);\n  });\n  return userArgs;\n}\n", "export function swallow<T>(f: () => T): T | undefined {\n  try {\n    return f();\n  } catch {\n    return undefined;\n  }\n}\n\nexport function pick<T extends object, K extends keyof T>(\n  obj: T,\n  ...keys: K[]\n): Pick<T, K> {\n  const res: any = {};\n  for (const key of keys) {\n    if (key in obj) {\n      res[key] = obj[key as keyof T];\n    }\n  }\n  return res;\n}\n\ntype ReactElt = {\n  children: ReactElt | ReactElt[];\n  props: {\n    children: ReactElt | ReactElt[];\n    [prop: string]: any;\n  } | null;\n  type: React.ComponentType<any> | null;\n  key: string | null;\n} | null;\n\nexport function traverseReactEltTree(\n  children: React.ReactNode,\n  callback: (elt: ReactElt) => void\n) {\n  const rec = (elts: ReactElt | ReactElt[] | null) => {\n    (Array.isArray(elts) ? elts : [elts]).forEach((elt) => {\n      if (elt) {\n        callback(elt);\n        if (elt.children) {\n          rec(elt.children);\n        }\n        if (elt.props?.children && elt.props.children !== elt.children) {\n          rec(elt.props.children);\n        }\n      }\n    });\n  };\n  rec(children as any);\n}\n\nexport function asArray<T>(x: T[] | T | undefined | null) {\n  if (Array.isArray(x)) {\n    return x;\n  } else if (x == null) {\n    return [];\n  } else {\n    return [x];\n  }\n}\n\nexport function ensureNumber(x: number | string): number {\n  return x as number;\n}\n\nexport function ensure<T>(x: T | null | undefined, msg: string): T {\n  if (x === null || x === undefined) {\n    throw new Error(\"Expected non-null or non-undefined value: \" + msg);\n  }\n  return x;\n}\n\nexport function isOneOf<T, U extends T>(elem: T, arr: readonly U[]): elem is U {\n  return arr.includes(elem as any);\n}\n\nexport function maybe<T, U>(\n  x: T | undefined | null,\n  f: (y: T) => U\n): U | undefined {\n  if (x === undefined || x === null) {\n    return undefined;\n  }\n  return f(x);\n}\n\nexport function isLikeImage(value: unknown) {\n  return typeof value === \"string\"\n    ? value.match(/\\.(png|jpg|jpeg|gif|svg|webp|avif|ico|bmp|tiff)$/i)\n    : false;\n}\n\nexport function ensureArray<T>(xs: T | T[]): T[] {\n  return Array.isArray(xs) ? xs : [xs];\n}\n\nexport const tuple = <T extends any[]>(...args: T): T => args;\n\nexport interface HasId {\n  id: string;\n}\n\nexport function mkIdMap<T extends HasId>(xs: ReadonlyArray<T>): Map<string, T> {\n  return new Map(xs.map((x) => tuple(x.id, x) as [string, T]));\n}\n\nexport const mkShortId = () => `${Math.random()}`;\n\nexport function withoutNils<T>(xs: Array<T | undefined | null>): T[] {\n  return xs.filter((x): x is T => x != null);\n}\n\nexport type Falsey = null | undefined | false | \"\" | 0 | 0n;\nexport type Truthy<T> = T extends Falsey ? never : T;\n\nexport function withoutFalsey<T>(xs: Array<T | Falsey>): T[] {\n  return xs.filter((x): x is T => !!x);\n}\n", "import { useMemo } from \"react\";\nimport {\n  ManyRowsResult,\n  TableFieldSchema,\n  TableFieldType,\n  TableSchema,\n} from \"./types\";\nimport { mkIdMap, withoutNils } from \"./utils\";\n\nexport type QueryResult = Partial<ManyRowsResult<any>> & {\n  error?: any;\n  isLoading?: boolean;\n};\n\nexport interface NormalizedData {\n  data: Record<string, unknown>[];\n  schema?: TableSchema;\n}\n\nexport function normalizeData(rawData: unknown): NormalizedData | undefined {\n  if (!rawData) {\n    return undefined;\n  }\n\n  const dataArray = tryGetDataArray(rawData);\n  if (!dataArray) {\n    return undefined;\n  }\n  const schema = (rawData as any).schema ?? tryGetSchema(dataArray);\n  if (!schema) {\n    return undefined;\n  }\n  return { data: dataArray, schema };\n}\n\nexport function useNormalizedData(\n  rawData: unknown\n): NormalizedData | undefined {\n  return useMemo(() => normalizeData(rawData), [rawData]);\n}\n\nfunction tryGetDataArray(rawData: unknown): any[] | undefined {\n  if (rawData == null || typeof rawData !== \"object\") {\n    return undefined;\n  }\n\n  if (Array.isArray(rawData)) {\n    if (isArrayOfObjects(rawData)) {\n      return rawData;\n    } else {\n      // TODO: array of primitives? Maybe we can wrap this?\n      return undefined;\n    }\n  }\n\n  if (rawData == null) {\n    return undefined;\n  }\n\n  if (\"data\" in rawData && typeof (rawData as any).data === \"object\") {\n    if (\n      Array.isArray((rawData as any).data) &&\n      isArrayOfObjects((rawData as any).data)\n    ) {\n      return (rawData as any).data;\n    } else if ((rawData as any).data != null) {\n      return [(rawData as any).data];\n    } else {\n      return undefined;\n    }\n  }\n  if (\"isLoading\" in rawData || \"error\" in rawData) {\n    return undefined;\n  }\n\n  // Maybe a singleton record?\n  return [rawData];\n}\n\nfunction isArrayOfObjects(arr: unknown[]) {\n  return arr.every((x) => typeof x === \"object\" && !Array.isArray(x));\n}\n\nfunction tryGetSchema(data: any[]): TableSchema | undefined {\n  const fieldMap: Record<string, TableFieldType> = {};\n  data.forEach((entry: any) => {\n    if (entry && typeof entry === \"object\") {\n      Array.from(Object.entries(entry)).forEach(([k, v]) => {\n        const inferredType: TableFieldType =\n          typeof v === \"string\"\n            ? \"string\"\n            : typeof v === \"boolean\"\n            ? \"boolean\"\n            : typeof v === \"number\"\n            ? \"number\"\n            : \"unknown\";\n        if (fieldMap[k] && fieldMap[k] !== inferredType) {\n          fieldMap[k] = \"unknown\";\n        } else {\n          fieldMap[k] = inferredType;\n        }\n      });\n    }\n  });\n  return {\n    id: \"inferred\",\n    fields: Object.entries(fieldMap).map(([f, t]) => ({\n      id: f,\n      type: t,\n      readOnly: false,\n    })),\n  };\n}\n\nexport type BaseFieldConfig = {\n  key?: string;\n  fieldId?: string;\n};\n\nconst mkShortId = () => `${Math.random()}`;\n\nexport function deriveFieldConfigs<T extends BaseFieldConfig>(\n  specifiedFieldsPartial: Partial<T>[],\n  schema: TableSchema | undefined,\n  makeDefaultConfig: (field: TableFieldSchema | undefined) => T\n): {\n  mergedFields: T[];\n  minimalFullLengthFields: Partial<T>[];\n} {\n  const schemaFields = schema?.fields ?? [];\n  const fieldById = mkIdMap(schemaFields);\n  const specifiedFieldIds = new Set(\n    withoutNils(specifiedFieldsPartial.map((f) => f.fieldId))\n  );\n  const keptSpecifiedFields = specifiedFieldsPartial.flatMap((f): T[] => {\n    if (!f.fieldId) {\n      return [\n        { key: mkShortId(), ...makeDefaultConfig(undefined), ...f },\n      ] as T[];\n    }\n    const field = fieldById.get(f.fieldId as string);\n\n    // Drop configs with fieldIds no longer in the data.\n    if (!field) {\n      return [];\n    }\n\n    return [\n      {\n        key: mkShortId(),\n        ...makeDefaultConfig(field),\n        ...f,\n      },\n    ] as T[];\n  });\n  const newVirtualFields = schemaFields\n    .filter((f) => !specifiedFieldIds.has(f.id))\n    .map(\n      (f): T => ({\n        key: mkShortId(),\n        ...makeDefaultConfig(f),\n      })\n    );\n  const mergedFields = [...keptSpecifiedFields, ...newVirtualFields];\n  const minimalFullLengthFields: Partial<T>[] = [\n    ...specifiedFieldsPartial,\n    ...newVirtualFields.map((f) => ({ key: f.key, fieldId: f.fieldId })),\n  ] as Partial<T>[];\n  return { mergedFields, minimalFullLengthFields };\n}\n", "import React from \"react\";\nimport { DataOpConfig } from \"../components/Fetcher\";\nimport { DataOp } from \"../types\";\nimport { swallow } from \"../utils\";\nimport { usePlasmicDataOp } from \"./usePlasmicDataOp\";\n\nfunction usePrevious<T>(value: T | undefined): T | undefined {\n  const prevValue = React.useRef<T | undefined>(undefined);\n\n  React.useEffect(() => {\n    prevValue.current = value;\n\n    return () => {\n      prevValue.current = undefined;\n    };\n  });\n\n  return prevValue.current;\n}\n\nexport interface DependencyAwareQueryConfig extends DataOpConfig {\n  $queries: Record<string, any>;\n  setDollarQueries: ($queries: Record<string, any>) => void;\n  getDataOp: () => DataOp;\n}\n\n/**\n * @deprecated Prefer using `usePlasmicDataOp` directly instead.\n */\nexport function useDependencyAwareQuery({\n  $queries,\n  getDataOp,\n  setDollarQueries,\n  name,\n  pageIndex,\n  pageSize,\n}: DependencyAwareQueryConfig) {\n  const data = usePlasmicDataOp(swallow(getDataOp), {\n    ...(!!pageIndex &&\n      !!pageSize && {\n        paginate: { pageIndex, pageSize },\n      }),\n  });\n  const finalName = name ?? \"data\";\n  const prevName = usePrevious(finalName);\n  React.useEffect(() => {\n    if (!(finalName in $queries) || $queries[finalName] !== data) {\n      const $queries2 = {\n        ...$queries,\n        [finalName]: data,\n      };\n      if (prevName && finalName !== prevName && prevName in $queries) {\n        delete $queries2[prevName];\n      }\n      setDollarQueries($queries2);\n    }\n  }, [finalName, prevName, data, $queries, setDollarQueries]);\n}\n", "import {\n  useMutablePlasmicQueryData,\n  wrapLoadingFetcher,\n} from \"@plasmicapp/query\";\nimport {\n  getConfig,\n  isPlasmicUndefinedDataErrorPromise,\n  usePlasmicFetch,\n} from \"../common\";\nimport { ClientQueryResult, ServerQuery, ServerQueryResult } from \"../types\";\nimport { pick } from \"../utils\";\nimport { resolveParams } from \"./common\";\n\ntype StudioCacheWrapper = <F extends (...args: any[]) => Promise<any>>(\n  id: string,\n  fn: F,\n  ...args: Parameters<F>\n) => Promise<any>;\n\nexport function makeQueryCacheKey(id: string, params: any[]) {\n  return `${id}:${JSON.stringify(params)}`;\n}\n\nexport function usePlasmicServerQuery<\n  F extends (...args: any[]) => Promise<any>\n>(\n  serverQuery: ServerQuery<F>,\n  fallbackData?: ReturnType<F>,\n  opts?: { noUndefinedDataProxy?: boolean }\n): Partial<ServerQueryResult<ReturnType<F>>> {\n  const resolvedParams = resolveParams(serverQuery.execParams, (err) => {\n    if (isPlasmicUndefinedDataErrorPromise(err)) {\n      return err;\n    }\n    // We are swallowing the error here because it may be an invalid\n    // access of a server query that is not yet ready\n    return null;\n  });\n  const key =\n    !resolvedParams || isPlasmicUndefinedDataErrorPromise(resolvedParams)\n      ? null\n      : makeQueryCacheKey(serverQuery.id, resolvedParams);\n  const wrapStudioCache: StudioCacheWrapper = getConfig(\n    \"EXECUTE_SERVER_QUERY\",\n    (_: string, fn: F, ...args: Parameters<F>) => fn(...args)\n  );\n\n  const fetcher = (params: Parameters<F>) => {\n    return wrapLoadingFetcher(wrapStudioCache)(\n      serverQuery.id,\n      serverQuery.fn,\n      ...params\n    );\n  };\n\n  const resultMapper = (\n    result: ReturnType<typeof useMutablePlasmicQueryData<ReturnType<F>, any>>\n  ): ClientQueryResult<ReturnType<F>> => {\n    return {\n      ...pick(result, \"data\", \"error\", \"isLoading\"),\n    };\n  };\n\n  return usePlasmicFetch(\n    key,\n    resolvedParams,\n    fetcher,\n    resultMapper,\n    [\"data\", \"error\"],\n    {\n      fallbackData,\n      ...opts,\n    }\n  );\n}\n", "/**\n * This returns either:\n * * The resolved params, if they are available.\n * * PlasmicUndefinedServerError, if when trying to evaluate the params,\n *   we encounter a PlasmicUndefinedServerError, so this operation cannot be\n *   performed until that dependency is resolved.\n * * Throws an error if the params function throws a normal error.\n */\nexport function resolveParams<F extends (...args: any[]) => any, E>(\n  params: () => Parameters<F>,\n  errorFn: (err: unknown) => E\n): Parameters<F> | E {\n  try {\n    return params();\n  } catch (err) {\n    return errorFn(err);\n  }\n}\n", "import { ServerQuery, ServerQueryResult } from \"../types\";\nimport { resolveParams } from \"./common\";\n\nclass PlasmicUndefinedServerError extends Error {\n  plasmicType: \"PlasmicUndefinedServerError\";\n  constructor(msg?: string) {\n    super(msg);\n    this.plasmicType = \"PlasmicUndefinedServerError\";\n  }\n}\n\nfunction isPlasmicUndefinedServerError(\n  x: any\n): x is PlasmicUndefinedServerError {\n  return (\n    !!x &&\n    typeof x === \"object\" &&\n    (x as any).plasmicType === \"PlasmicUndefinedServerError\"\n  );\n}\n\nexport function mkPlasmicUndefinedServerProxy() {\n  return {\n    data: new Proxy(\n      {},\n      {\n        get: (_, prop) => {\n          if (prop === \"isUndefinedServerProxy\") {\n            return true;\n          } else if (prop === \"then\") {\n            return undefined;\n          }\n          throw new PlasmicUndefinedServerError(\"Data is not available yet\");\n        },\n      }\n    ),\n    isLoading: true,\n  };\n}\n\n/**\n * Executes a server query, returning either the result of the query or a\n * PlasmicUndefinedServerProxy if the query depends on data that is not yet ready\n */\nexport async function executeServerQuery<F extends (...args: any[]) => any>(\n  serverQuery: ServerQuery<F>\n): Promise<ServerQueryResult<ReturnType<F> | {}>> {\n  const resolvedParams = resolveParams(serverQuery.execParams, (err) => {\n    if (isPlasmicUndefinedServerError(err)) {\n      return err;\n    }\n    throw err;\n  });\n  if (isPlasmicUndefinedServerError(resolvedParams)) {\n    return mkPlasmicUndefinedServerProxy();\n  }\n  return { data: await serverQuery.fn(...resolvedParams), isLoading: false };\n}\n"],
  "mappings": "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",
  "names": ["usePlasmicDataConfig", "React", "usePlasmicDataConfig", "React", "data", "_a", "getConfig", "usePlasmicDataConfig", "React", "React", "React", "wrapLoadingFetcher", "wrapLoadingFetcher"]
}
