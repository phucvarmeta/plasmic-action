"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setMetadataEnv = exports.generateMetadata = exports.getContext = exports.readLock = void 0;
const Sentry = __importStar(require("@sentry/node"));
const lodash_1 = __importDefault(require("lodash"));
const querystring = __importStar(require("querystring"));
const upath_1 = __importDefault(require("upath"));
const init_1 = require("../actions/init");
const api_1 = require("../api");
const deps_1 = require("../deps");
const migrations_1 = require("../migrations/migrations");
const error_1 = require("../utils/error");
const auth_utils_1 = require("./auth-utils");
const config_utils_1 = require("./config-utils");
const file_utils_1 = require("./file-utils");
const lang_utils_1 = require("./lang-utils");
const npm_utils_1 = require("./npm-utils");
const prompts = __importStar(require("./prompts"));
function createPlasmicLock() {
    return {
        projects: [],
        cliVersion: npm_utils_1.getCliVersion(),
    };
}
function readLock(lockFile) {
    if (!file_utils_1.existsBuffered(lockFile)) {
        return createPlasmicLock();
    }
    try {
        const result = JSON.parse(file_utils_1.readFileText(lockFile));
        return Object.assign({}, result);
    }
    catch (e) {
        deps_1.logger.error(`Error encountered reading ${config_utils_1.LOCK_FILE_NAME} at ${lockFile}: ${e}`);
        throw e;
    }
}
exports.readLock = readLock;
function removeMissingFilesFromLock(context, config, lock) {
    const knownProjects = Object.fromEntries(config.projects.map((project) => [project.projectId, project]));
    const knownGlobalVariants = Object.fromEntries(context.config.globalVariants.variantGroups.map((vg) => [vg.projectId, vg]));
    lock.projects = lock.projects
        .filter((project) => knownProjects[project.projectId])
        .map((project) => {
        const knownComponents = Object.fromEntries(knownProjects[project.projectId].components.map((component) => [
            component.id,
            component,
        ]));
        const knownImages = Object.fromEntries(knownProjects[project.projectId].images.map((image) => [
            image.id,
            image,
        ]));
        const knownIcons = Object.fromEntries(knownProjects[project.projectId].icons.map((icons) => [icons.id, icons]));
        project.fileLocks = project.fileLocks.filter((lock) => {
            switch (lock.type) {
                default:
                    return false;
                case "projectCss":
                    return knownProjects[project.projectId].cssFilePath;
                case "globalVariant":
                    return knownGlobalVariants[project.projectId];
                case "cssRules":
                case "renderModule":
                    return knownComponents[lock.assetId];
                case "image":
                    return knownImages[lock.assetId];
                case "icon":
                    return knownIcons[lock.assetId];
                case "globalContexts":
                    return knownProjects[project.projectId].globalContextsFilePath;
            }
        });
        return project;
    });
}
/**
 *
 * @param context
 * @param expectedPath
 * @param baseNameToFiles
 * @returns The path if we are able to find the file, undefined if we need to recreate it
 * @throws if the user interrupts flow
 */
function attemptToRestoreFilePath(context, expectedPath, baseNameToFiles) {
    return __awaiter(this, void 0, void 0, function* () {
        // If the path is not set, always recreate.
        if (expectedPath === "") {
            return undefined;
        }
        if (file_utils_1.fileExists(context, expectedPath)) {
            return expectedPath;
        }
        const fileName = upath_1.default.basename(expectedPath);
        if (!baseNameToFiles[fileName]) {
            const answer = yield prompts.askChoice({
                message: `File ${upath_1.default.join(context.absoluteSrcDir, expectedPath)} not found. Do you want to recreate it?`,
                choices: ["Yes", "No"],
                defaultAnswer: "Yes",
                hidePrompt: context.cliArgs.yes,
            });
            if (answer === "No") {
                throw new error_1.HandledError("Please add this file or update your plasmic.json by removing or changing this path and try again.");
            }
            return undefined;
        }
        if (baseNameToFiles[fileName].length === 1) {
            const newPath = upath_1.default.relative(context.absoluteSrcDir, baseNameToFiles[fileName][0]);
            deps_1.logger.info(`\tDetected file moved from ${expectedPath} to ${newPath}.`);
            return newPath;
        }
        // Multiple files
        const none = "None.";
        const answer = yield prompts.askChoice({
            message: `Cannot find expected file at ${expectedPath}. Please select one of the following matches:`,
            choices: [...baseNameToFiles[fileName], none],
            defaultAnswer: none,
            hidePrompt: context.cliArgs.yes,
        });
        if (answer === none) {
            throw new error_1.HandledError("Please add this file or update your plasmic.json by removing or changing this path and try again.");
        }
        return answer;
    });
}
function resolveMissingFilesInConfig(context, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const baseNameToFiles = file_utils_1.buildBaseNameToFiles(context);
        // Make sure all the files exist. Prompt the user / exit process if not.
        function filterFiles(list, pathProp) {
            return __awaiter(this, void 0, void 0, function* () {
                const newList = [];
                for (const item of list) {
                    const newPath = yield attemptToRestoreFilePath(context, item[pathProp], baseNameToFiles);
                    if (newPath) {
                        item[pathProp] = newPath;
                        newList.push(item);
                    }
                }
                return newList;
            });
        }
        context.config.globalVariants.variantGroups = yield filterFiles(context.config.globalVariants.variantGroups, "contextFilePath");
        // Try to find the file, otherwise recreate at either the specified path or default path (if both are falsey)
        context.config.style.defaultStyleCssFilePath =
            (yield attemptToRestoreFilePath(context, context.config.style.defaultStyleCssFilePath, baseNameToFiles)) || context.config.style.defaultStyleCssFilePath;
        // Try to find the file, otherwise recreate at either the specified path or default path (if both are falsey)
        for (const project of config.projects) {
            project.cssFilePath =
                (yield attemptToRestoreFilePath(context, project.cssFilePath, baseNameToFiles)) || project.cssFilePath;
            if (!project.globalContextsFilePath) {
                project.globalContextsFilePath = "";
            }
            // Try to find the file, otherwise recreate at either the specified path or default path (if both are falsey)
            project.globalContextsFilePath =
                (yield attemptToRestoreFilePath(context, project.globalContextsFilePath, baseNameToFiles)) || project.globalContextsFilePath;
            project.images = yield filterFiles(project.images, "filePath");
            project.icons = yield filterFiles(project.icons, "moduleFilePath");
            project.jsBundleThemes = yield filterFiles(project.jsBundleThemes || [], "themeFilePath");
            // For components, if they decide to recreate in any of the path (css, wrapper, or blackbox component)
            // we'll delete existing files.
            const newComponents = [];
            for (const component of project.components) {
                if (component.type === "mapped") {
                    // For components mapped to an external module, we skip restoring files on disk
                    newComponents.push(component);
                    continue;
                }
                const newModulePath = yield attemptToRestoreFilePath(context, component.importSpec.modulePath, baseNameToFiles);
                if (!newModulePath) {
                    continue;
                }
                const newRenderModulePath = yield attemptToRestoreFilePath(context, component.renderModuleFilePath, baseNameToFiles);
                if (!newRenderModulePath) {
                    continue;
                }
                const newCssPath = yield attemptToRestoreFilePath(context, component.cssFilePath, baseNameToFiles);
                if (!newCssPath) {
                    continue;
                }
                component.importSpec.modulePath = newModulePath;
                component.renderModuleFilePath = newRenderModulePath;
                component.cssFilePath = newCssPath;
                newComponents.push(component);
            }
            project.components = newComponents;
        }
    });
}
function getContext(args, { enableSkipAuth = false } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!args.baseDir)
            args.baseDir = process.cwd();
        const auth = enableSkipAuth
            ? yield getCurrentOrDefaultAuth(args)
            : yield getOrInitAuth(args);
        /** Sentry */
        if (auth.host.startsWith(config_utils_1.DEFAULT_HOST)) {
            // Production usage of cli
            Sentry.init({
                dsn: "https://3ed4eb43d28646e381bf3c50cff24bd6@o328029.ingest.sentry.io/5285892",
            });
            Sentry.configureScope((scope) => {
                if (auth.user) {
                    scope.setUser({ email: auth.user });
                }
                scope.setExtra("cliVersion", npm_utils_1.getCliVersion());
                scope.setExtra("args", JSON.stringify(args));
                scope.setExtra("host", auth.host);
            });
        }
        /** PlasmicConfig **/
        let configFile = args.config || config_utils_1.findConfigFile(args.baseDir, { traverseParents: true });
        if (!configFile) {
            yield maybeRunPlasmicInit(args, "plasmic.json", enableSkipAuth);
            configFile = config_utils_1.findConfigFile(args.baseDir, { traverseParents: true });
            if (!configFile) {
                const err = new error_1.HandledError("No plasmic.json file found. Please run `plasmic init` first.");
                throw err;
            }
        }
        const rootDir = upath_1.default.dirname(configFile);
        // plasmic.lock should be in the same directory as plasmic.json
        const lockFile = upath_1.default.join(rootDir, config_utils_1.LOCK_FILE_NAME);
        yield migrations_1.runNecessaryMigrations(configFile, lockFile, args.baseDir, args.yes);
        const config = config_utils_1.readConfig(configFile, true);
        /** PlasmicLock */
        const lock = readLock(lockFile);
        const context = {
            config,
            configFile,
            lock,
            lockFile,
            rootDir,
            absoluteSrcDir: upath_1.default.isAbsolute(config.srcDir)
                ? config.srcDir
                : upath_1.default.resolve(rootDir, config.srcDir),
            auth,
            api: new api_1.PlasmicApi(auth),
            cliArgs: args,
        };
        yield resolveMissingFilesInConfig(context, config);
        removeMissingFilesFromLock(context, config, lock);
        return context;
    });
}
exports.getContext = getContext;
/**
 * Use empty user/token to signify no auth (only returning to provide a default host).
 */
function getCurrentOrDefaultAuth(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const auth = yield auth_utils_1.getCurrentAuth(args.auth);
        if (auth) {
            return auth;
        }
        return {
            host: config_utils_1.DEFAULT_HOST,
            user: "",
            token: "",
        };
    });
}
function getOrInitAuth(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const auth = yield auth_utils_1.getCurrentAuth(args.auth);
        if (auth) {
            return auth;
        }
        if (yield maybeRunPlasmicInit(args, ".plasmic.auth")) {
            return lang_utils_1.ensure(yield auth_utils_1.getCurrentAuth());
        }
        // Could not find the authentication credentials and the user
        // declined to run plasmic init.
        throw new error_1.HandledError("Could not authenticate.");
    });
}
function maybeRunPlasmicInit(args, missingFile, enableSkipAuth) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!process.env.QUIET) {
            deps_1.logger.info(`No ${missingFile} file found. Initializing plasmic...`);
        }
        yield init_1.initPlasmic(Object.assign({ host: config_utils_1.DEFAULT_HOST, platform: "", codeLang: "", codeScheme: "", styleScheme: "", imagesScheme: "", srcDir: "", plasmicDir: "", imagesPublicDir: "", imagesPublicUrlPrefix: "", enableSkipAuth }, args));
        return true;
    });
}
/**
 * Create a metadata bundle
 * This will be used to tag Segment events (e.g. for codegen)
 * Merges in:
 * 1. defaults
 * 2. PLASMIC_METADATA environment variable settings
 * 3. arguments from the command-line
 * to create a single Metadata object for Segment
 * @param defaults
 * @param fromArgs
 */
function generateMetadata(defaults, fromArgs) {
    const fromEnv = process.env.PLASMIC_METADATA;
    const metadataFromEnv = !fromEnv ? {} : Object.assign({}, querystring.decode(fromEnv));
    const metadataFromArgs = !fromArgs ? {} : Object.assign({}, querystring.decode(fromArgs));
    // Priority: 1. args 2. env 3. defaults
    const metadata = lodash_1.default.assign(Object.assign({}, defaults), metadataFromEnv, metadataFromArgs);
    return metadata;
}
exports.generateMetadata = generateMetadata;
/**
 * This is meant to be called from consumers of the CLI to set
 * metadata into the PLASMIC_METADATA environment variable
 * @param metadata
 */
function setMetadataEnv(metadata) {
    const fromEnv = process.env.PLASMIC_METADATA
        ? querystring.decode(process.env.PLASMIC_METADATA)
        : {};
    const env = Object.assign({}, fromEnv);
    lodash_1.default.toPairs(metadata).forEach(([k, v]) => {
        if (!env[k]) {
            env[k] = v;
        }
    });
    process.env.PLASMIC_METADATA = querystring.encode(env);
}
exports.setMetadataEnv = setMetadataEnv;
