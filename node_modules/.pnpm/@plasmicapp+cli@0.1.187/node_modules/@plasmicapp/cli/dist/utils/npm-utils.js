"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectPackageManager = exports.installCommand = exports.installUpgrade = exports.findPackageJsonDir = exports.isCliGloballyInstalled = exports.findInstalledVersion = exports.warnLatest = exports.getParsedPackageJson = exports.checkEngineStrict = exports.getCliVersion = exports.getParsedCliPackageJson = void 0;
const child_process_1 = require("child_process");
const fast_glob_1 = __importDefault(require("fast-glob"));
const findup_sync_1 = __importDefault(require("findup-sync"));
const latest_version_1 = __importDefault(require("latest-version"));
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
const deps_1 = require("../deps");
const file_utils_1 = require("./file-utils");
const user_utils_1 = require("./user-utils");
function getParsedCliPackageJson() {
    const packageJson = findup_sync_1.default("package.json", { cwd: __dirname });
    if (!packageJson) {
        throw new Error(`Cannot find package.json in ancestors of ${__dirname}`);
    }
    return parsePackageJson(packageJson);
}
exports.getParsedCliPackageJson = getParsedCliPackageJson;
function getCliVersion() {
    const j = getParsedCliPackageJson();
    return j.version;
}
exports.getCliVersion = getCliVersion;
/**
 * Call this to check if we match the engine policy
 */
function checkEngineStrict() {
    var _a;
    const pkg = getParsedCliPackageJson();
    const minNodeVersion = (_a = pkg === null || pkg === void 0 ? void 0 : pkg.engines) === null || _a === void 0 ? void 0 : _a.node;
    if (!!minNodeVersion && !semver_1.default.satisfies(process.version, minNodeVersion)) {
        deps_1.logger.warn(`Plasmic only works on Node ${minNodeVersion}`);
        return false;
    }
    return true;
}
exports.checkEngineStrict = checkEngineStrict;
function getParsedPackageJson() {
    const packageJson = findup_sync_1.default("package.json");
    if (!packageJson) {
        throw new Error(`Cannot find package.json`);
    }
    return parsePackageJson(packageJson);
}
exports.getParsedPackageJson = getParsedPackageJson;
// @TODO: is this function still used?
function warnLatest(context, pkg, baseDir, msgs, yes) {
    return __awaiter(this, void 0, void 0, function* () {
        const check = yield checkVersion(context, baseDir, pkg);
        if (check.type === "up-to-date") {
            return;
        }
        else if (check.type === "wrong-npm-registry") {
            deps_1.logger.warn(`${msgs.requiredMsg()} Unable to find this package in your npm registry. Please update this dependency manually.`);
            return;
        }
        if (yield user_utils_1.confirmWithUser(`${check.type === "not-installed"
            ? msgs.requiredMsg()
            : msgs.updateMsg(check.current, check.latest)}  Do you want to ${check.type === "not-installed" ? "add" : "update"} it now?`, yes)) {
            installUpgrade(pkg, baseDir);
        }
    });
}
exports.warnLatest = warnLatest;
function checkVersion(context, baseDir, pkg) {
    return __awaiter(this, void 0, void 0, function* () {
        // Try to get the latest version from npm
        let last = null;
        try {
            last = yield latest_version_1.default(pkg);
        }
        catch (e) {
            // This is likely because .npmrc is set to a different registry
            return { type: "wrong-npm-registry" };
        }
        const cur = findInstalledVersion(context, baseDir, pkg);
        if (!cur) {
            return { type: "not-installed" };
        }
        if (semver_1.default.gt(last, cur)) {
            return {
                type: "obsolete",
                latest: last,
                current: cur,
            };
        }
        return { type: "up-to-date" };
    });
}
function findInstalledVersion(context, baseDir, pkg) {
    var _a;
    const pm = detectPackageManager(baseDir);
    if (pm === "yarn2") {
        try {
            const pkgInfo = JSON.parse(child_process_1.execSync(`yarn info --json ${pkg}`).toString().trim());
            return (_a = pkgInfo === null || pkgInfo === void 0 ? void 0 : pkgInfo.children) === null || _a === void 0 ? void 0 : _a.Version;
        }
        catch (_) {
            return undefined;
        }
    }
    const filename = findInstalledPackageJsonFile(context, pkg);
    if (filename) {
        const json = parsePackageJson(filename);
        if (json && json.name === pkg) {
            return json.version;
        }
    }
    return undefined;
}
exports.findInstalledVersion = findInstalledVersion;
/**
 * Detects if the cli is globally installed.  `rootDir` is the folder
 * where plasmic.json is
 */
function isCliGloballyInstalled(rootDir) {
    const packageJsonFile = findPackageJsonPath(rootDir);
    if (!packageJsonFile) {
        // We assume global, as instructions state global and we can't really
        // do better
        return true;
    }
    const installedDir = __dirname;
    // Else, we assume it is local if the installedDir is a subfolder of
    // the root project dir
    return !installedDir.startsWith(path_1.default.dirname(packageJsonFile));
}
exports.isCliGloballyInstalled = isCliGloballyInstalled;
function findPackageJsonPath(dir) {
    return file_utils_1.findFile(dir, (f) => f === "package.json", {
        traverseParents: true,
    });
}
function findPackageJsonDir(rootDir) {
    const filePath = findPackageJsonPath(rootDir);
    return filePath ? path_1.default.dirname(filePath) : undefined;
}
exports.findPackageJsonDir = findPackageJsonDir;
function findInstalledPackageJsonFile(context, pkg) {
    const packageJsonPath = findPackageJsonPath(context.rootDir);
    const rootDir = packageJsonPath
        ? path_1.default.dirname(packageJsonPath)
        : context.rootDir;
    const files = fast_glob_1.default.sync(`${rootDir}/**/node_modules/${pkg}/package.json`, {
        ignore: [`**/node_modules/**/node_modules/**`],
    });
    return files.length > 0 ? files[0] : undefined;
}
function parsePackageJson(path) {
    try {
        return JSON.parse(file_utils_1.readFileText(path));
    }
    catch (e) {
        return undefined;
    }
}
function installUpgrade(pkg, baseDir, opts = {}) {
    const cmd = installCommand(pkg, baseDir, opts);
    if (!process.env.QUIET) {
        deps_1.logger.info(cmd);
    }
    const r = child_process_1.spawnSync(cmd, {
        shell: true,
        stdio: process.env.QUIET ? "ignore" : "inherit",
        cwd: baseDir,
    });
    if (r.status === 0) {
        if (!process.env.QUIET) {
            deps_1.logger.info(`Successfully added ${pkg} dependency.`);
        }
        return true;
    }
    else {
        deps_1.logger.warn(`Cannot add ${pkg} to your project dependencies. Please add it manually.`);
        return false;
    }
}
exports.installUpgrade = installUpgrade;
function installCommand(pkg, baseDir, opts = {}) {
    const mgr = detectPackageManager(baseDir);
    if (mgr === "yarn") {
        if (opts.global) {
            return `yarn global add ${pkg}`;
        }
        else if (opts.dev) {
            return `yarn add --dev --ignore-scripts -W ${pkg}`;
        }
        else {
            return `yarn add --ignore-scripts -W ${pkg}`;
        }
    }
    else if (mgr === "yarn2") {
        if (opts.global) {
            // yarn2 does not support global.
            return `npm install -g ${pkg}`;
        }
        else if (opts.dev) {
            return `yarn add -D ${pkg}`;
        }
        else {
            return `yarn add ${pkg}`;
        }
    }
    else {
        if (opts.global) {
            return `npm install -g ${pkg}`;
        }
        else if (opts.dev) {
            return `npm install --save-dev --ignore-scripts ${pkg}`;
        }
        else {
            return `npm install --ignore-scripts ${pkg}`;
        }
    }
}
exports.installCommand = installCommand;
function detectPackageManager(baseDir) {
    const yarnLock = findup_sync_1.default("yarn.lock", { cwd: baseDir });
    if (yarnLock) {
        const yarnVersion = child_process_1.execSync(`yarn --version`).toString().trim();
        return semver_1.default.gte(yarnVersion, "2.0.0") ? "yarn2" : "yarn";
    }
    return "npm";
}
exports.detectPackageManager = detectPackageManager;
