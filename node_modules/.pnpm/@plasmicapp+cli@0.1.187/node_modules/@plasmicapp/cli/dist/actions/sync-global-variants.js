"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncGlobalVariants = void 0;
const lodash_1 = __importDefault(require("lodash"));
const upath_1 = __importDefault(require("upath"));
const deps_1 = require("../deps");
const code_utils_1 = require("../utils/code-utils");
const config_utils_1 = require("../utils/config-utils");
const file_utils_1 = require("../utils/file-utils");
const lang_utils_1 = require("../utils/lang-utils");
function syncGlobalVariants(context, projectMeta, bundles, checksums, baseDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const projectId = projectMeta.projectId;
        const projectLock = config_utils_1.getOrAddProjectLock(context, projectId);
        const existingVariantConfigs = lodash_1.default.keyBy(context.config.globalVariants.variantGroups.filter((group) => group.projectId === projectId), (c) => c.id);
        const globalVariantFileLocks = lodash_1.default.keyBy(projectLock.fileLocks.filter((fileLock) => fileLock.type === "globalVariant"), (fl) => fl.assetId);
        const id2VariantChecksum = new Map(checksums.globalVariantChecksums);
        const variantBundleIds = lodash_1.default.keyBy(bundles, (i) => i.id);
        const deletedGlobalVariants = lodash_1.default.filter(existingVariantConfigs, (i) => !variantBundleIds[i.id] && !id2VariantChecksum.has(i.id));
        for (const bundle of bundles) {
            if (context.cliArgs.quiet !== true) {
                deps_1.logger.info(`Syncing global variant ${bundle.name} [${projectId}/${bundle.id}]`);
            }
            let variantConfig = existingVariantConfigs[bundle.id];
            const isNew = !variantConfig;
            const defaultContextFilePath = file_utils_1.defaultResourcePath(context, projectMeta, bundle.contextFileName);
            if (isNew) {
                variantConfig = {
                    id: bundle.id,
                    name: bundle.name,
                    projectId,
                    contextFilePath: defaultContextFilePath,
                };
                existingVariantConfigs[bundle.id] = variantConfig;
                context.config.globalVariants.variantGroups.push(variantConfig);
            }
            else {
                const contextFilePath = upath_1.default.join(upath_1.default.dirname(variantConfig.contextFilePath), upath_1.default.basename(defaultContextFilePath));
                if (variantConfig.contextFilePath !== contextFilePath &&
                    file_utils_1.fileExists(context, variantConfig.contextFilePath)) {
                    if (context.cliArgs.quiet !== true) {
                        deps_1.logger.info(`Renaming global variant: ${variantConfig.name} [${projectId}/${bundle.id}]`);
                    }
                    file_utils_1.renameFile(context, variantConfig.contextFilePath, contextFilePath);
                    variantConfig.contextFilePath = contextFilePath;
                }
                variantConfig.name = bundle.name;
            }
            // Update FileLocks
            if (globalVariantFileLocks[bundle.id]) {
                globalVariantFileLocks[bundle.id].checksum = lang_utils_1.ensure(id2VariantChecksum.get(bundle.id));
            }
            else {
                projectLock.fileLocks.push({
                    type: "globalVariant",
                    assetId: bundle.id,
                    checksum: lang_utils_1.ensure(id2VariantChecksum.get(bundle.id)),
                });
            }
            yield file_utils_1.writeFileContent(context, variantConfig.contextFilePath, code_utils_1.formatAsLocal(bundle.contextModule, variantConfig.contextFilePath, baseDir), { force: !isNew });
        }
        const deletedVariantsFiles = new Set();
        for (const deletedGlobalVariant of deletedGlobalVariants) {
            const variantConfig = existingVariantConfigs[deletedGlobalVariant.id];
            if (file_utils_1.fileExists(context, variantConfig.contextFilePath)) {
                deps_1.logger.info(`Deleting global variant: ${variantConfig.name} [${projectId}/${deletedGlobalVariant.id}]`);
                file_utils_1.deleteFile(context, variantConfig.contextFilePath);
                deletedVariantsFiles.add(deletedGlobalVariant.id);
            }
        }
        context.config.globalVariants.variantGroups = context.config.globalVariants.variantGroups.filter((v) => !deletedVariantsFiles.has(v.id));
        const deletedVariantIds = new Set(deletedGlobalVariants.map((i) => i.id));
        projectLock.fileLocks = projectLock.fileLocks.filter((fileLock) => fileLock.type !== "globalVariant" ||
            !deletedVariantIds.has(fileLock.assetId));
    });
}
exports.syncGlobalVariants = syncGlobalVariants;
