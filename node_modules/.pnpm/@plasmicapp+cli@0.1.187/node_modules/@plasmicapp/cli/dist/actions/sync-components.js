"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncProjectComponents = void 0;
const code_merger_1 = require("@plasmicapp/code-merger");
const lodash_1 = __importDefault(require("lodash"));
const upath_1 = __importDefault(require("upath"));
const api_1 = require("../api");
const deps_1 = require("../deps");
const code_utils_1 = require("../utils/code-utils");
const config_utils_1 = require("../utils/config-utils");
const error_1 = require("../utils/error");
const file_utils_1 = require("../utils/file-utils");
const lang_utils_1 = require("../utils/lang-utils");
const user_utils_1 = require("../utils/user-utils");
const updateDirectSkeleton = (newFileContent, editedFileContent, context, compConfig, forceOverwrite, nameInIdToUuid, appendJsxOnMissingBase) => __awaiter(void 0, void 0, void 0, function* () {
    // merge code!
    const componentByUuid = new Map();
    componentByUuid.set(compConfig.id, {
        editedFile: editedFileContent,
        newFile: newFileContent,
        newNameInIdToUuid: new Map(nameInIdToUuid),
    });
    const mergedFiles = yield code_merger_1.mergeFiles(componentByUuid, compConfig.projectId, code_merger_1.makeCachedProjectSyncDataProvider((projectId, revision) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            return yield context.api.projectSyncMetadata(projectId, revision, true);
        }
        catch (e) {
            if (e instanceof api_1.AppServerError &&
                /revision \d+ not found/.test(e.message)) {
                throw e;
            }
            else {
                lang_utils_1.assert(e instanceof Error);
                throw new error_1.HandledError(e.message);
            }
        }
    })), () => { }, appendJsxOnMissingBase);
    const merged = mergedFiles === null || mergedFiles === void 0 ? void 0 : mergedFiles.get(compConfig.id);
    if (merged) {
        yield file_utils_1.writeFileContent(context, compConfig.importSpec.modulePath, merged, {
            force: true,
        });
    }
    else {
        if (!forceOverwrite) {
            throw new error_1.HandledError(`Cannot merge ${compConfig.importSpec.modulePath}. If you just switched the code scheme for the component from blackbox to direct, use --force-overwrite option to force the switch.`);
        }
        else {
            deps_1.logger.warn(`Overwrite ${compConfig.importSpec.modulePath} despite merge failure`);
            yield file_utils_1.writeFileContent(context, compConfig.importSpec.modulePath, newFileContent, {
                force: true,
            });
        }
    }
});
function syncProjectComponents(context, project, version, componentBundles, forceOverwrite, appendJsxOnMissingBase, summary, pendingMerge, projectLock, checksums, baseDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const componentsFromChecksums = new Set([
            ...checksums.cssRulesChecksums.map(([id, _]) => id),
            checksums.renderModuleChecksums.map(([id, _]) => id),
        ]);
        const allCompConfigs = lodash_1.default.keyBy(project.components, (c) => c.id);
        const componentBundleIds = lodash_1.default.keyBy(componentBundles, (i) => i.id);
        const deletedComponents = lodash_1.default.filter(allCompConfigs, (i) => !componentBundleIds[i.id] && !componentsFromChecksums.has(i.id));
        const renderModuleFileLocks = lodash_1.default.keyBy(projectLock.fileLocks.filter((fileLock) => fileLock.type === "renderModule"), (fl) => fl.assetId);
        const cssRulesFileLocks = lodash_1.default.keyBy(projectLock.fileLocks.filter((fileLock) => fileLock.type === "cssRules"), (fl) => fl.assetId);
        const id2RenderModuleChecksum = new Map(checksums.renderModuleChecksums);
        const id2CssRulesChecksum = new Map(checksums.cssRulesChecksums);
        const deletedComponentFiles = new Set();
        for (const deletedComponent of deletedComponents) {
            const componentConfig = allCompConfigs[deletedComponent.id];
            if (file_utils_1.fileExists(context, componentConfig.renderModuleFilePath) &&
                file_utils_1.fileExists(context, componentConfig.cssFilePath)) {
                deps_1.logger.info(`Deleting component: ${componentConfig.name}@${version}\t['${project.projectName}' ${project.projectId}/${componentConfig.id} ${project.version}]`);
                file_utils_1.deleteFile(context, componentConfig.renderModuleFilePath);
                file_utils_1.deleteFile(context, componentConfig.cssFilePath);
                deletedComponentFiles.add(deletedComponent.id);
                const skeletonPath = componentConfig.importSpec.modulePath;
                if (file_utils_1.fileExists(context, skeletonPath)) {
                    const deleteSkeleton = yield user_utils_1.confirmWithUser(`Do you want to delete ${skeletonPath}?`, context.cliArgs.yes);
                    if (deleteSkeleton) {
                        file_utils_1.deleteFile(context, skeletonPath);
                    }
                }
            }
        }
        project.components = project.components.filter((c) => !deletedComponentFiles.has(c.id));
        const deletedComponentIds = new Set(deletedComponents.map((i) => i.id));
        projectLock.fileLocks = projectLock.fileLocks.filter((fileLock) => (fileLock.type !== "renderModule" && fileLock.type !== "cssRules") ||
            !deletedComponentIds.has(fileLock.assetId));
        for (const bundle of componentBundles) {
            const { renderModule, skeletonModule, cssRules, renderModuleFileName, skeletonModuleFileName, cssFileName, componentName, id, scheme, nameInIdToUuid, isPage, plumeType, } = bundle;
            if (context.cliArgs.quiet !== true) {
                deps_1.logger.info(`Syncing component: ${componentName}@${version}\t['${project.projectName}' ${project.projectId}/${id} ${project.version}]`);
            }
            let compConfig = allCompConfigs[id];
            // A component should be regenerated if it is new or path-related information (like the name)
            // changed.
            const shouldRegenerate = (compConfig === null || compConfig === void 0 ? void 0 : compConfig.name) !== componentName;
            let skeletonModuleModified = shouldRegenerate;
            const skeletonPath = isPage
                ? file_utils_1.defaultPagePath(context, skeletonModuleFileName)
                : skeletonModuleFileName;
            const defaultRenderModuleFilePath = file_utils_1.defaultResourcePath(context, project, renderModuleFileName);
            const defaultCssFilePath = file_utils_1.defaultResourcePath(context, project, cssFileName);
            if (shouldRegenerate) {
                project.components = project.components.filter((existingComponent) => existingComponent.id !== id);
                compConfig = {
                    id,
                    name: componentName,
                    type: "managed",
                    projectId: project.projectId,
                    renderModuleFilePath: defaultRenderModuleFilePath,
                    importSpec: { modulePath: skeletonPath },
                    cssFilePath: defaultCssFilePath,
                    scheme: scheme,
                    componentType: isPage ? "page" : "component",
                    plumeType,
                };
                allCompConfigs[id] = compConfig;
                project.components.push(allCompConfigs[id]);
                // Because it's the first time, we also generate the skeleton file.
                yield file_utils_1.writeFileContent(context, skeletonPath, skeletonModule, {
                    force: false,
                });
            }
            else if (compConfig.type === "mapped") {
            }
            else if (compConfig.type === "managed") {
                // This is an existing component.
                // We only bother touching files on disk if this component is managed.
                compConfig.componentType = isPage ? "page" : "component";
                // Read in the existing file
                let editedFile;
                try {
                    editedFile = file_utils_1.readFileContent(context, compConfig.importSpec.modulePath);
                }
                catch (e) {
                    deps_1.logger.warn(`${compConfig.importSpec.modulePath} is missing. If you deleted this component, remember to remove the component from ${config_utils_1.CONFIG_FILE_NAME}`);
                    throw e;
                }
                const renderModuleFilePath = upath_1.default.join(upath_1.default.dirname(compConfig.renderModuleFilePath), upath_1.default.basename(defaultRenderModuleFilePath));
                if (compConfig.renderModuleFilePath !== renderModuleFilePath &&
                    file_utils_1.fileExists(context, compConfig.renderModuleFilePath)) {
                    if (context.cliArgs.quiet !== true) {
                        deps_1.logger.info(`Renaming component file: ${compConfig.renderModuleFilePath}@${version}\t['${project.projectName}' ${project.projectId}/${id} ${project.version}]`);
                    }
                    file_utils_1.renameFile(context, compConfig.renderModuleFilePath, renderModuleFilePath);
                    compConfig.renderModuleFilePath = renderModuleFilePath;
                }
                const cssFilePath = upath_1.default.join(upath_1.default.dirname(compConfig.cssFilePath), upath_1.default.basename(defaultCssFilePath));
                if (compConfig.cssFilePath !== cssFilePath &&
                    file_utils_1.fileExists(context, compConfig.cssFilePath)) {
                    if (context.cliArgs.quiet !== true) {
                        deps_1.logger.info(`Renaming component css file: ${compConfig.cssFilePath}@${version}\t['${project.projectName}' ${project.projectId}/${id} ${project.version}]`);
                    }
                    file_utils_1.renameFile(context, compConfig.cssFilePath, cssFilePath);
                    compConfig.cssFilePath = cssFilePath;
                }
                if (isPage &&
                    config_utils_1.isPageAwarePlatform(context.config.platform) &&
                    !file_utils_1.eqPagePath(skeletonPath, compConfig.importSpec.modulePath) &&
                    file_utils_1.fileExists(context, compConfig.importSpec.modulePath)) {
                    if (context.cliArgs.quiet !== true) {
                        deps_1.logger.info(`Renaming page file: ${compConfig.importSpec.modulePath} -> ${skeletonPath}\t['${project.projectName}' ${project.projectId}/${id} ${project.version}]`);
                    }
                    file_utils_1.renameFile(context, compConfig.importSpec.modulePath, skeletonPath);
                    compConfig.importSpec.modulePath = skeletonPath;
                }
                compConfig.plumeType = plumeType;
                if (scheme === "direct") {
                    // We cannot merge right now, but wait until all the imports are resolved
                    pendingMerge.push({
                        skeletonModulePath: compConfig.importSpec.modulePath,
                        editedSkeletonFile: editedFile,
                        newSkeletonFile: skeletonModule,
                        merge: (resolvedNewFile, resolvedEditedFile) => __awaiter(this, void 0, void 0, function* () {
                            return updateDirectSkeleton(resolvedNewFile, resolvedEditedFile, context, compConfig, forceOverwrite, nameInIdToUuid, appendJsxOnMissingBase);
                        }),
                    });
                    skeletonModuleModified = true;
                }
                else if (/\/\/\s*plasmic-managed-jsx\/\d+/.test(editedFile)) {
                    if (forceOverwrite) {
                        skeletonModuleModified = true;
                        yield file_utils_1.writeFileContent(context, compConfig.importSpec.modulePath, skeletonModule, {
                            force: true,
                        });
                    }
                    else {
                        deps_1.logger.warn(`file ${compConfig.importSpec.modulePath} is likely in "direct" scheme. If you intend to switch the code scheme from direct to blackbox, use --force-overwrite option to force the switch.`);
                    }
                }
            }
            lang_utils_1.assert(lodash_1.default.isArray(projectLock.fileLocks));
            // Update FileLocks
            if (renderModuleFileLocks[id]) {
                renderModuleFileLocks[id].checksum = lang_utils_1.ensure(id2RenderModuleChecksum.get(id));
            }
            else {
                projectLock.fileLocks.push({
                    type: "renderModule",
                    assetId: id,
                    checksum: lang_utils_1.ensure(id2RenderModuleChecksum.get(id)),
                });
            }
            if (cssRulesFileLocks[id]) {
                cssRulesFileLocks[id].checksum = lang_utils_1.ensure(id2CssRulesChecksum.get(id));
            }
            else {
                projectLock.fileLocks.push({
                    type: "cssRules",
                    assetId: id,
                    checksum: lang_utils_1.ensure(id2CssRulesChecksum.get(id)),
                });
            }
            if (compConfig.type === "managed") {
                // Again, only need to touch files on disk if managed
                yield file_utils_1.writeFileContent(context, compConfig.renderModuleFilePath, renderModule, {
                    force: !shouldRegenerate,
                });
                const formattedCssRules = code_utils_1.formatAsLocal(cssRules, compConfig.cssFilePath, baseDir);
                yield file_utils_1.writeFileContent(context, compConfig.cssFilePath, formattedCssRules, {
                    force: !shouldRegenerate,
                });
            }
            summary.set(id, { skeletonModuleModified });
        }
    });
}
exports.syncProjectComponents = syncProjectComponents;
