"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeAuth = exports.findAuthFile = exports.getOrStartAuth = exports.getCurrentAuth = exports.getEnvAuth = exports.readAuth = exports.startAuth = exports.authByPolling = void 0;
const fs_1 = __importDefault(require("fs"));
const inquirer_1 = __importDefault(require("inquirer"));
const open_1 = __importDefault(require("open"));
const os_1 = __importDefault(require("os"));
const socket_io_client_1 = __importDefault(require("socket.io-client"));
const upath_1 = __importDefault(require("upath"));
const uuid_1 = require("uuid");
const api_1 = require("../api");
const deps_1 = require("../deps");
const error_1 = require("../utils/error");
const config_utils_1 = require("./config-utils");
const file_utils_1 = require("./file-utils");
function authByPolling(host, initToken) {
    const socket = socket_io_client_1.default.connect(host, {
        path: `/api/v1/init-token`,
        transportOptions: {
            polling: {
                extraHeaders: {
                    "x-plasmic-init-token": initToken,
                },
            },
        },
    });
    const promise = new Promise((resolve, reject) => {
        socket.on("connect", (reason) => {
            deps_1.logger.info("Waiting for token...");
        });
        socket.on("token", (data) => {
            resolve(data);
            socket.close();
        });
        socket.on("error", (error) => {
            deps_1.logger.warn(error);
            reject(error);
        });
    });
    const cancel = () => {
        socket.close();
    };
    return { promise, cancel };
}
exports.authByPolling = authByPolling;
function authByPrompt(host) {
    const promise = inquirer_1.default.prompt([
        {
            name: "user",
            message: "Your Plasmic user email",
        },
        {
            name: "token",
            message: `Your personal access token (create one at ${host}/self/settings)`,
        },
    ]);
    const cancel = () => {
        deps_1.logger.info("Cancelling prompt...");
        process.stdin.pause();
    };
    return { promise, cancel };
}
function startAuth(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (opts.yes) {
            throw new error_1.HandledError("Plasmic credentials could not be found.");
        }
        const auth = yield new Promise((resolve, reject) => {
            let prompt;
            const initToken = uuid_1.v4();
            const url = `${opts.host}/auth/plasmic-init/${initToken}`;
            open_1.default(url);
            deps_1.logger.info(`\nIf your browser doesn't automatically open, enter the following URL:\n${url}\n`);
            deps_1.logger.info(`Please log in and authorize Plasmic CLI.`);
            const polling = authByPolling(opts.host, initToken);
            polling.promise.then((auth) => {
                if (prompt) {
                    prompt.cancel();
                }
                else {
                    clearTimeout(timeout);
                }
                resolve(auth);
            });
            // Default to 1 minute.
            const authPollTimeout = Number(process.env.PLASMIC_AUTH_POLL_TIMEOUT) || 60 * 1000;
            if (authPollTimeout === -1) {
                return;
            }
            const timeout = setTimeout(() => {
                deps_1.logger.info(`We haven't received an auth token from Plasmic yet.`);
                prompt = authByPrompt(opts.host);
                prompt.promise
                    .then((auth) => {
                    polling.cancel();
                    resolve(auth);
                })
                    .catch(reject);
            }, authPollTimeout);
        });
        if (!auth.user || !auth.token) {
            deps_1.logger.error(`Could not get auth token.`);
            return;
        }
        const newAuthFile = opts.auth || upath_1.default.join(os_1.default.homedir(), config_utils_1.AUTH_FILE_NAME);
        yield writeAuth(newAuthFile, {
            host: opts.host,
            user: auth.user,
            token: auth.token,
        });
        deps_1.logger.info(`Successfully created Plasmic credentials file at ${newAuthFile}`);
    });
}
exports.startAuth = startAuth;
function readAuth(authFile) {
    if (!file_utils_1.existsBuffered(authFile)) {
        throw new error_1.HandledError(`No Plasmic auth file found at ${authFile}`);
    }
    try {
        const parsed = JSON.parse(file_utils_1.readFileText(authFile));
        // Strip trailing slashes.
        return Object.assign(Object.assign({}, parsed), { host: parsed.host.replace(/\/+$/, "") });
    }
    catch (e) {
        deps_1.logger.error(`Error encountered reading plasmic credentials at ${authFile}: ${e}`);
        throw e;
    }
}
exports.readAuth = readAuth;
function getEnvAuth() {
    const host = process.env[config_utils_1.ENV_AUTH_HOST];
    const user = process.env[config_utils_1.ENV_AUTH_USER];
    const token = process.env[config_utils_1.ENV_AUTH_TOKEN];
    // both user and token are required
    if (!user || !token) {
        // Try to give a hint if they partially entered a credential
        if (user || token) {
            deps_1.logger.warn(`Your Plasmic credentials were only partially set via environment variables. Try both ${config_utils_1.ENV_AUTH_USER} and ${config_utils_1.ENV_AUTH_TOKEN}`);
        }
        return;
    }
    return {
        host: host !== null && host !== void 0 ? host : config_utils_1.DEFAULT_HOST,
        user,
        token,
    };
}
exports.getEnvAuth = getEnvAuth;
function readCurrentAuth(authPath) {
    const authFromEnv = getEnvAuth();
    if (authFromEnv)
        return authFromEnv;
    if (!authPath && !process.env.PLASMIC_DISABLE_AUTH_SEARCH) {
        authPath = findAuthFile(process.cwd(), { traverseParents: true });
    }
    if (!authPath) {
        return undefined;
    }
    return readAuth(authPath);
}
function getCurrentAuth(authPath) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const auth = readCurrentAuth(authPath);
        if (!auth) {
            return undefined;
        }
        const api = new api_1.PlasmicApi(auth);
        try {
            yield api.getCurrentUser();
            return auth;
        }
        catch (e) {
            if (((_a = e.response) === null || _a === void 0 ? void 0 : _a.status) === 401) {
                deps_1.logger.error(`The current credentials expired or are not valid.`);
                return undefined;
            }
            throw e;
        }
    });
}
exports.getCurrentAuth = getCurrentAuth;
function failAuth() {
    throw new error_1.HandledError(`Unable to authenticate Plasmic. Please run 'plasmic auth'.`);
}
function getOrStartAuth(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        let auth = yield getCurrentAuth(opts.auth);
        if (!auth && opts.enableSkipAuth) {
            return;
        }
        if (!auth && opts.yes) {
            failAuth();
        }
        if (!auth) {
            yield startAuth(opts);
            auth = yield getCurrentAuth(opts.auth);
        }
        if (!auth) {
            failAuth();
        }
        return auth;
    });
}
exports.getOrStartAuth = getOrStartAuth;
function findAuthFile(dir, opts) {
    let file = file_utils_1.findFile(dir, (f) => f === config_utils_1.AUTH_FILE_NAME, opts);
    if (!file) {
        file = file_utils_1.findFile(os_1.default.homedir(), (f) => f === config_utils_1.AUTH_FILE_NAME, {
            traverseParents: false,
        });
    }
    return file;
}
exports.findAuthFile = findAuthFile;
function writeAuth(authFile, config) {
    return __awaiter(this, void 0, void 0, function* () {
        yield file_utils_1.writeFileContentRaw(authFile, JSON.stringify(config, undefined, 2), {
            force: true,
        });
        fs_1.default.chmodSync(authFile, "600");
    });
}
exports.writeAuth = writeAuth;
