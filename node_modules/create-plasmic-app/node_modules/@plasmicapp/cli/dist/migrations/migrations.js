"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runNecessaryMigrations = exports.LOCK_MIGRATIONS = exports.MIGRATIONS = void 0;
/**
 * Super simple migration framework for cli.
 *
 * If you want to run some migration script (say, to fix up the schema of plasmic.json, etc),
 * you should:
 *
 * 1. Bump your cli version.
 * 2. Add a [version]-[desc].ts file to the migrations folder, exporting a function that takes
 *    the previous version of plasmic.json (or plasmic.lock) blob, and returns the new version
 *    of plasmic.json (or plasmic.lock) blob.
 * 3. Add the migration function to the MIGRATIONS (or LOCK_MIGRATIONS) dict in this file.
 *
 * The framework will run migrations in sequence, so you are guaranteed that the plasmic.json blob
 * passed into your migration function is valid as of the previous version.
 */
const chalk_1 = __importDefault(require("chalk"));
const lodash_1 = __importDefault(require("lodash"));
const semver_1 = __importDefault(require("semver"));
const upath_1 = __importDefault(require("upath"));
const deps_1 = require("../deps");
const config_utils_1 = require("../utils/config-utils");
const error_1 = require("../utils/error");
const file_utils_1 = require("../utils/file-utils");
const npm_utils_1 = require("../utils/npm-utils");
const user_utils_1 = require("../utils/user-utils");
const _0_1_110_fileLocks_1 = require("./0.1.110-fileLocks");
const _0_1_146_addReactRuntime_1 = require("./0.1.146-addReactRuntime");
const _0_1_166_indirect_1 = require("./0.1.166-indirect");
const _0_1_27_migrateInit_1 = require("./0.1.27-migrateInit");
const _0_1_28_tsToTsx_1 = require("./0.1.28-tsToTsx");
const _0_1_31_ensureProjectIcons_1 = require("./0.1.31-ensureProjectIcons");
const _0_1_42_ensureVersion_1 = require("./0.1.42-ensureVersion");
const _0_1_57_ensureJsBundleThemes_1 = require("./0.1.57-ensureJsBundleThemes");
const _0_1_64_imageFiles_1 = require("./0.1.64-imageFiles");
const _0_1_95_componentType_1 = require("./0.1.95-componentType");
exports.MIGRATIONS = {
    "0.1.27": _0_1_27_migrateInit_1.migrateInit,
    "0.1.28": _0_1_28_tsToTsx_1.tsToTsx,
    "0.1.31": _0_1_31_ensureProjectIcons_1.ensureProjectIcons,
    "0.1.42": _0_1_42_ensureVersion_1.ensureVersion,
    "0.1.57": _0_1_57_ensureJsBundleThemes_1.ensureJsBundleThemes,
    "0.1.64": _0_1_64_imageFiles_1.ensureImageFiles,
    "0.1.95": _0_1_95_componentType_1.ensureComponentType,
    "0.1.146": _0_1_146_addReactRuntime_1.ensureReactRuntime,
    "0.1.166": _0_1_166_indirect_1.ensureIndirect,
};
exports.LOCK_MIGRATIONS = {
    "0.1.110": _0_1_110_fileLocks_1.ensureFileLocks,
};
function runNecessaryMigrations(configFile, lockFile, baseDir, yes) {
    return __awaiter(this, void 0, void 0, function* () {
        const cliVersion = npm_utils_1.getCliVersion();
        // If we don't have a lock file, we don't need to run migrations on it!
        const maybeReadLock = () => {
            if (file_utils_1.existsBuffered(lockFile)) {
                return JSON.parse(file_utils_1.readFileText(lockFile));
            }
            return undefined;
        };
        const cur = config_utils_1.readConfig(configFile, false);
        const curVersion = cur.cliVersion;
        if (!!curVersion && semver_1.default.lt(cliVersion, curVersion)) {
            const confirm = yield user_utils_1.confirmWithUser(`Project requires @plasmicapp/cli>=${curVersion} (You currently have ${cliVersion}). Would you like to upgrade it?`, yes);
            if (!confirm) {
                throw new error_1.HandledError("Upgrading is required to continue.");
            }
            const success = npm_utils_1.installUpgrade("@plasmicapp/cli", baseDir, {
                global: npm_utils_1.isCliGloballyInstalled(upath_1.default.dirname(configFile)),
                dev: true,
            });
            deps_1.logger.info(chalk_1.default.bold("@plasmicapp/cli has been upgraded; please try again!"));
            throw new error_1.HandledError(success ? "" : "Error upgrading @plasmicapp/cli");
        }
        const context = {
            absoluteSrcDir: upath_1.default.isAbsolute(cur.srcDir)
                ? cur.srcDir
                : upath_1.default.resolve(upath_1.default.dirname(configFile), cur.srcDir),
        };
        const greaterVersions = semver_1.default.sort([...lodash_1.default.keys(exports.MIGRATIONS), ...lodash_1.default.keys(exports.LOCK_MIGRATIONS)].filter((v) => !curVersion || semver_1.default.gt(v, curVersion)));
        for (const version of greaterVersions) {
            deps_1.logger.info(`Migrating to plasmic.json version ${version}`);
            const migrationFunc = exports.MIGRATIONS[version];
            if (migrationFunc !== undefined) {
                const prev = config_utils_1.readConfig(configFile, false);
                const next = migrationFunc(prev, context);
                next.cliVersion = version;
                yield config_utils_1.writeConfig(configFile, next, baseDir);
            }
            const lockMigrationFunc = exports.LOCK_MIGRATIONS[version];
            if (lockMigrationFunc !== undefined) {
                const prev = maybeReadLock();
                if (prev) {
                    const next = lockMigrationFunc(prev, context);
                    yield config_utils_1.writeLock(lockFile, next, baseDir);
                }
            }
        }
        // Finally, stamp the latest version
        const latestConfig = config_utils_1.readConfig(configFile, false);
        if (latestConfig.cliVersion !== cliVersion) {
            latestConfig.cliVersion = cliVersion;
            yield config_utils_1.writeConfig(configFile, latestConfig, baseDir);
        }
    });
}
exports.runNecessaryMigrations = runNecessaryMigrations;
