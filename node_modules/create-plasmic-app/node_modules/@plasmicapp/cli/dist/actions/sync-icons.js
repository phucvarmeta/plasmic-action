"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncProjectIconAssets = void 0;
const lodash_1 = __importDefault(require("lodash"));
const upath_1 = __importDefault(require("upath"));
const deps_1 = require("../deps");
const code_utils_1 = require("../utils/code-utils");
const config_utils_1 = require("../utils/config-utils");
const file_utils_1 = require("../utils/file-utils");
const lang_utils_1 = require("../utils/lang-utils");
function syncProjectIconAssets(context, projectId, version, iconBundles, checksums, baseDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const project = config_utils_1.getOrAddProjectConfig(context, projectId);
        if (!project.icons) {
            project.icons = [];
        }
        const projectLock = config_utils_1.getOrAddProjectLock(context, projectId);
        const knownIconConfigs = lodash_1.default.keyBy(project.icons, (i) => i.id);
        const iconFileLocks = lodash_1.default.keyBy(projectLock.fileLocks.filter((fileLock) => fileLock.type === "icon"), (fl) => fl.assetId);
        const id2IconChecksum = new Map(checksums.iconChecksums);
        const iconBundleIds = lodash_1.default.keyBy(iconBundles, (i) => i.id);
        const deletedIcons = lodash_1.default.filter(knownIconConfigs, (i) => !iconBundleIds[i.id] && !id2IconChecksum.has(i.id));
        for (const bundle of iconBundles) {
            if (context.cliArgs.quiet !== true) {
                deps_1.logger.info(`Syncing icon: ${bundle.name}@${version}\t['${project.projectName}' ${project.projectId}/${bundle.id} ${project.version}]`);
            }
            let iconConfig = knownIconConfigs[bundle.id];
            const isNew = !iconConfig;
            const defaultModuleFilePath = file_utils_1.defaultResourcePath(context, project, "icons", bundle.fileName);
            if (isNew) {
                iconConfig = {
                    id: bundle.id,
                    name: bundle.name,
                    moduleFilePath: defaultModuleFilePath,
                };
                knownIconConfigs[bundle.id] = iconConfig;
                project.icons.push(iconConfig);
            }
            else {
                const moduleFilePath = upath_1.default.join(upath_1.default.dirname(iconConfig.moduleFilePath), upath_1.default.basename(defaultModuleFilePath));
                if (iconConfig.moduleFilePath !== moduleFilePath &&
                    file_utils_1.fileExists(context, iconConfig.moduleFilePath)) {
                    if (context.cliArgs.quiet !== true) {
                        deps_1.logger.info(`Renaming icon: ${iconConfig.name}@${version}\t['${project.projectName}' ${project.projectId}/${bundle.id} ${project.version}]`);
                    }
                    file_utils_1.renameFile(context, iconConfig.moduleFilePath, moduleFilePath);
                    iconConfig.moduleFilePath = moduleFilePath;
                }
                iconConfig.name = bundle.name;
            }
            // Update FileLocks
            if (iconFileLocks[bundle.id]) {
                iconFileLocks[bundle.id].checksum = lang_utils_1.ensure(id2IconChecksum.get(bundle.id));
            }
            else {
                projectLock.fileLocks.push({
                    type: "icon",
                    assetId: bundle.id,
                    checksum: lang_utils_1.ensure(id2IconChecksum.get(bundle.id)),
                });
            }
            yield file_utils_1.writeFileContent(context, iconConfig.moduleFilePath, code_utils_1.formatAsLocal(bundle.module, iconConfig.moduleFilePath, baseDir), {
                force: !isNew,
            });
        }
        const deletedIconFiles = new Set();
        for (const deletedIcon of deletedIcons) {
            const iconConfig = knownIconConfigs[deletedIcon.id];
            if (file_utils_1.fileExists(context, iconConfig.moduleFilePath)) {
                deps_1.logger.info(`Deleting icon: ${iconConfig.name}@${version}\t['${project.projectName}' ${project.projectId}/${deletedIcon.id} ${project.version}]`);
                file_utils_1.deleteFile(context, iconConfig.moduleFilePath);
                deletedIconFiles.add(deletedIcon.id);
            }
        }
        project.icons = project.icons.filter((i) => !deletedIconFiles.has(i.id));
        const deletedIconIds = new Set(deletedIcons.map((i) => i.id));
        projectLock.fileLocks = projectLock.fileLocks.filter((fileLock) => fileLock.type !== "icon" || !deletedIconIds.has(fileLock.assetId));
    });
}
exports.syncProjectIconAssets = syncProjectIconAssets;
