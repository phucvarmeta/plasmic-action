"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tuple = exports.assert = exports.AssertionError = exports.ensureString = exports.ensure = exports.flatMap = void 0;
const lodash_1 = __importDefault(require("lodash"));
function flatMap(arr, f) {
    const r = [];
    for (const x of arr) {
        r.push(...f(x));
    }
    return r;
}
exports.flatMap = flatMap;
function ensure(x, msg = "") {
    if (x === null || x === undefined) {
        debugger;
        msg = (lodash_1.default.isString(msg) ? msg : msg()) || "";
        throw new Error(`Value must not be undefined or null${msg ? `- ${msg}` : ""}`);
    }
    else {
        return x;
    }
}
exports.ensure = ensure;
function ensureString(x) {
    if (lodash_1.default.isString(x)) {
        return x;
    }
    else {
        throw new Error(`Expected ${x} to be a string`);
    }
}
exports.ensureString = ensureString;
class AssertionError extends Error {
    constructor(msg = "Assertion failed") {
        super(msg);
    }
}
exports.AssertionError = AssertionError;
function assert(cond, msg = "Assertion failed") {
    if (!cond) {
        // We always generate an non empty message so that it doesn't get swallowed
        // by the async library.
        msg = (lodash_1.default.isString(msg) ? msg : msg()) || "Assertion failed";
        debugger;
        throw new AssertionError(msg);
    }
}
exports.assert = assert;
exports.tuple = (...args) => args;
